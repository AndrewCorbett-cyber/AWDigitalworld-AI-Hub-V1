<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWDigitalworld AI Studio Pro - With Presets & Metadata</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽ¨</text></svg>">


    <!-- Server Configuration -->
    <script>
        // Server version configuration
        window.SERVER_CONFIG = {
            apiUrl: '/api',
            comfyuiUrl: '/comfyui',
            wsUrl: (window.location.protocol === 'https:' ? 'wss://' : 'ws://') +
                window.location.host + '/comfyui/ws',
            version: '4.0.0'
        };

        // Mock electronAPI for compatibility
        window.electronAPI = {
            getConfig: async () => {
                const response = await fetch('/api/config');
                return await response.json();
            },
            saveConfig: async (config) => {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                return await response.json();
            },
            testConnection: async (url) => {
                const response = await fetch('/api/test-connection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                return await response.json();
            },
            getSystemStats: async () => {
                const response = await fetch('/api/system-stats');
                return await response.json();
            },
            openSettings: async () => {
                window.open('/settings', 'settings', 'width=600,height=500');
            }
        };
        // Patched useEffect to force proxy path
        //useEffect(() => {
        // Determine the base ComfyUI URL to use for requests.
        // In the browser server version, this MUST be the relative proxy path '/comfyui'
        // to avoid CORS issues.
        //const defaultUrl = window.SERVER_CONFIG.comfyuiUrl; // Should be '/comfyui'

        //setServerUrl(defaultUrl);
        //connectToServer(defaultUrl);

        // NOTE: The original electronAPI check is removed here to prevent
        // it from loading the absolute URL from /api/config, which causes CORS.

        // }, []);

    </script>

    <style>
        /**
     * AWDigitalworld AI Hub Pro V5 - Modern 2026 Edition
     * Completely redesigned CSS with modern design principles
     * All React functionality preserved - CSS-only transformation
     * FIXES: Added missing Modal/Metadata/Header styles, fixed tab-bar margins, fixed stats bar position.
     */
    
        /* ===== DESIGN TOKENS ===== */
        :root {
            /* Colors - Professional 2026 Theme */
            --bg-primary: #0A0E1A;
            --bg-secondary: #131823;
            --bg-tertiary: #1A1F2E;
            --bg-glass: rgba(19, 24, 35, 0.7);
    
            /* Accents */
            --accent-primary: #6366F1;
            --accent-secondary: #EC4899;
            --accent-gradient: linear-gradient(135deg, #6366F1 0%, #EC4899 100%);
            --accent-glow: 0 0 20px rgba(99, 102, 241, 0.3);
    
            /* Text */
            --text-primary: #F9FAFB;
            --text-secondary: #9CA3AF;
            --text-tertiary: #6B7280;
    
            /* Status */
            --success: #10B981;
            --warning: #F59E0B;
            --error: #EF4444;
            --info: #3B82F6;
    
            /* Spacing (8px grid) */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
    
            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-full: 9999px;
    
            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            --shadow-xl: 0 20px 60px rgba(0, 0, 0, 0.6);
    
            /* Transitions */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 250ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
    
            --stat-track: rgba(255, 255, 255, 0.05);
            /* New color for stat bar background */
        }
    
        /* ===== RESET & BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'Roboto', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    
        /* ===== APP CONTAINER & HEADER (NEW) ===== */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: var(--space-md);
            background:
                radial-gradient(circle at 10% 20%, rgba(99, 102, 241, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(236, 72, 153, 0.1) 0%, transparent 40%),
                var(--bg-primary);
        }
    
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xs) 0 var(--space-md) 0;
            margin-left: 200px;
            /* Offset to align with tab bar */
        }
    
        .app-title {
            font-size: 20px;
            font-weight: 800;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 0.5px;
        }
    
        .header-actions {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
    
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: var(--radius-full);
            font-size: 12px;
            font-weight: 600;
        }
    
        .status-connected {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }
    
        .status-disconnected {
            background: rgba(239, 68, 68, 0.2);
            color: var(--error);
        }
    
        .voice-button {
            padding: 8px 16px;
            border-radius: var(--radius-full);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            font-size: 14px;
            cursor: pointer;
            border: none;
            transition: all var(--transition-fast);
            font-weight: 600;
        }
    
        .voice-button:hover {
            background: var(--accent-primary);
            color: white;
        }
    
        .voice-button.listening {
            background: var(--error);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }
    
        /* ===== STATS DISPLAY (FIXED POSITION) ===== */
        .stats-container {
            /* CRITICAL FIX: Changed from 'absolute' to 'fixed' for correct floating */
            position: fixed;
            top: 60px;
            /* Adjusted slightly */
            left: var(--space-md);
            width: 180px;
            padding: var(--space-md) var(--space-sm);
            background: var(--bg-glass);
            backdrop-filter: blur(8px);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
            z-index: 999;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: var(--shadow-md);
        }
    
        .stat-bar {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
    
        .stat-bar-label {
            font-size: 10px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }
    
        .stat-bar-track {
            height: 4px;
            background: var(--stat-track);
            border-radius: var(--radius-full);
            overflow: hidden;
        }
    
        .stat-bar-fill {
            height: 100%;
            transition: width var(--transition-fast);
        }
    
        /* Sidebar Toggle Button */
        .sidebar-toggle {
            position: fixed;
            /* Changed to fixed to float over content */
            top: 10px;
            left: var(--space-md);
            width: 40px;
            height: 40px;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            z-index: 1000;
            color: var(--text-secondary);
            font-size: 18px;
        }
    
        .sidebar-toggle:hover {
            background: var(--accent-primary);
            color: white;
            transform: scale(1.1);
            box-shadow: var(--accent-glow);
        }
    
        /* ===== TAB BAR (Modernized) FIXES ===== */
        .tab-bar {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            padding: 6px;
            border-radius: var(--radius-full);
            margin-bottom: var(--space-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: var(--shadow-md);
            /* FIX: Adjusted margin to clear the fixed stats bar and align with the app header */
            margin-left: 200px;
        }
    
        .tab-bar.collapsed {
            flex-direction: column;
            width: 56px;
            padding: var(--space-sm);
            margin-left: 50px;
            /* Account for the collapsed sidebar toggle */
        }
    
        .tab-bar.collapsed .tab {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            padding: 12px 8px;
        }
    
        .tab {
            flex: 1;
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: var(--radius-full);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }
    
        .tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }
    
        .tab.active {
            background: var(--accent-gradient);
            color: white;
            box-shadow: var(--accent-glow);
            /* CRITICAL FIX: REMOVED erroneous margin-left which was breaking the layout */
            /* margin-left: 200px; */
        }
    
        /* ===== MAIN CONTENT ===== */
        .main-content {
            flex: 1;
            display: flex;
            gap: var(--space-md);
            overflow: hidden;
        }
    
        .tab-content {
            display: none;
            flex: 1;
        }
    
        .tab-content.active {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
    
        .generation-panel {
            display: flex;
            flex-direction: column;
            flex: 1;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            padding: var(--space-lg);
            box-shadow: var(--shadow-md);
            overflow: hidden;
        }
    
        .controls-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: var(--space-lg);
            height: 100%;
            overflow: hidden;
        }
    
        .accordion {
            height: 100%;
            overflow-y: auto;
            padding-right: var(--space-sm);
        }
    
        .preview-panel {
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            padding: var(--space-lg);
            box-shadow: var(--shadow-md);
            height: 100%;
            min-width: 300px;
        }
    
        .preview-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-md);
            overflow: hidden;
        }
    
        .preview-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
    
        /* ===== PANELS (Base kept for other tabs) ===== */
        .panel {
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            padding: var(--space-lg);
            box-shadow: var(--shadow-md);
        }
    
        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-lg);
        }
    
        .panel-title {
            font-size: 18px;
            font-weight: 700;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    
        .panel-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
        }
    
        /* ===== FORM ELEMENTS ===== */
        .form-group {
            margin-bottom: var(--space-lg);
        }
    
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    
        input[type="text"],
        input[type="number"],
        input[type="email"],
        input[type="password"],
        textarea,
        select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            transition: all var(--transition-fast);
        }
    
        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: rgba(255, 255, 255, 0.05);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
    
        textarea {
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }
    
        select {
            cursor: pointer;
            /* Using a custom arrow icon for dark theme, but keeping original for compatibility */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%239CA3AF' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }
    
        .horizontal-row {
            display: flex;
            gap: var(--space-md);
        }
    
        .horizontal-row .form-group {
            flex: 1;
        }
    
        .face-upload-preview {
            width: 100%;
            height: 100px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            margin-top: var(--space-sm);
        }
    
        .face-upload-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
    
        /* ===== BUTTONS ===== */
        button,
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            font-family: inherit;
        }
    
        .btn-primary {
            background: var(--accent-gradient);
            color: white;
            box-shadow: var(--shadow-sm);
        }
    
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--accent-glow);
        }
    
        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
        }
    
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    
        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    
        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.1);
        }
    
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }
    
        .btn-large {
            padding: 14px 24px;
            font-size: 16px;
        }
    
        /* ===== ACCORDION ===== */
        .accordion-section {
            margin-bottom: var(--space-sm);
        }
    
        .accordion-header {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background var(--transition-fast), border-color var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    
        .accordion-header:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--accent-primary);
        }
    
        .accordion-icon {
            transition: transform var(--transition-fast);
            color: var(--accent-primary);
        }
    
        .accordion-header.active .accordion-icon {
            transform: rotate(90deg);
        }
    
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--transition-base) ease-in-out;
        }
    
        .accordion-content.open {
            max-height: 2000px;
            padding: var(--space-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-top: none;
            border-radius: 0 0 var(--radius-sm) var(--radius-sm);
            background: rgba(255, 255, 255, 0.02);
        }
    
        .accordion-body {
            padding: 0;
        }
    
        /* ===== GALLERY ===== */
        .gallery-panel {
            display: flex;
            flex-direction: column;
            flex: 1;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            padding: var(--space-lg);
            box-shadow: var(--shadow-md);
            overflow: hidden;
        }
    
        .gallery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }
    
        .gallery-content {
            flex: 1;
            overflow-y: auto;
        }
    
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-md);
            padding: var(--space-xs);
            /* Reduced padding to fit better */
        }
    
        .gallery-item {
            position: relative;
            border-radius: var(--radius-md);
            overflow: hidden;
            cursor: pointer;
            transition: all var(--transition-fast);
            border: 2px solid transparent;
            aspect-ratio: 1;
        }
    
        .gallery-item:hover {
            transform: translateY(-4px);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-lg);
        }
    
        .gallery-item img,
        .gallery-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
    
        /* Gallery Overlays and Info (NEW) */
        .gallery-item-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            padding: var(--space-sm);
            opacity: 0;
            transition: opacity var(--transition-fast);
            display: flex;
            flex-direction: column;
        }
    
        .gallery-item:hover .gallery-item-info {
            opacity: 1;
        }
    
        .gallery-item-tag {
            font-size: 10px;
            font-weight: 600;
            color: var(--accent-secondary);
            text-transform: uppercase;
            margin-bottom: 2px;
        }
    
        .gallery-item-size {
            font-size: 11px;
            color: var(--text-secondary);
        }
    
        .gallery-item-watermark {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-weight: 700;
            z-index: 10;
            opacity: 0.8;
        }
    
        .gallery-empty {
            text-align: center;
            padding: 50px;
            color: var(--text-secondary);
            border: 2px dashed rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            margin: var(--space-lg);
        }
    
        .gallery-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--space-md);
            margin-top: var(--space-md);
            padding-bottom: var(--space-sm);
        }
    
        .pagination-button {
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: none;
            cursor: pointer;
            font-size: 12px;
        }
    
        .pagination-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
    
        /* ===== PROGRESS & ERROR STATUS ===== */
        .progress-container {
            width: 80%;
            max-width: 400px;
            text-align: center;
        }
    
        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-full);
            overflow: hidden;
            margin-bottom: var(--space-sm);
        }
    
        .progress-bar-inner {
            height: 100%;
            background: var(--accent-gradient);
            border-radius: var(--radius-full);
            transition: width var(--transition-base);
        }
    
        .progress-text {
            font-size: 12px;
            color: var(--text-secondary);
        }
    
        .error-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            animation: fadeIn 0.2s;
        }
    
        .error-content {
            background: var(--bg-secondary);
            border: 1px solid var(--error);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-xl);
            text-align: left;
        }
    
        .error-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--error);
            margin-bottom: var(--space-md);
        }
    
        .error-details {
            background: rgba(239, 68, 68, 0.1);
            padding: var(--space-sm);
            border-radius: var(--radius-sm);
            margin-bottom: var(--space-md);
        }
    
        /* ===== IMAGE MODAL & METADATA (NEW) ===== */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: var(--space-lg);
            animation: fadeIn 0.3s;
        }
    
        .image-modal-content {
            display: flex;
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: var(--shadow-xl);
        }
    
        .image-modal .modal-close {
            position: fixed;
            top: var(--space-md);
            right: var(--space-md);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            z-index: 10000;
        }
    
        .modal-left {
            flex: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-md);
            min-width: 400px;
            max-height: 80vh;
        }
    
        .modal-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: var(--radius-md);
        }
    
        .modal-right {
            flex: 1;
            padding: var(--space-lg);
            min-width: 350px;
            overflow-y: auto;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }
    
        .metadata-section {
            background: var(--bg-tertiary);
            padding: var(--space-md);
            border-radius: var(--radius-sm);
        }
    
        .metadata-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: var(--space-sm);
            text-transform: uppercase;
        }
    
        .metadata-prompt {
            font-size: 12px;
            color: var(--text-primary);
            word-break: break-word;
            margin-bottom: var(--space-sm);
        }
    
        .metadata-buttons {
            text-align: right;
        }
    
        .metadata-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.05);
        }
    
        .metadata-label {
            font-size: 11px;
            color: var(--text-secondary);
        }
    
        .metadata-value {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-primary);
        }
    
        .metadata-lora-list {
            margin-top: 4px;
            padding: 4px;
            border-left: 2px solid var(--accent-secondary);
            font-size: 11px;
        }
    
        /* ===== PROMPT LIBRARY (NEW) ===== */
        .search-bar input {
            width: 100%;
            margin-bottom: var(--space-sm);
        }
    
        .tag-badge {
            display: inline-flex;
            padding: 4px 8px;
            background: rgba(99, 102, 241, 0.2);
            border-radius: var(--radius-full);
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-primary);
            cursor: pointer;
            transition: all var(--transition-fast);
        }
    
        .tag-badge:hover {
            background: var(--accent-primary);
            color: white;
        }
    
        .prompt-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: var(--space-md);
        }
    
        .prompt-card {
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all var(--transition-fast);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
    
        .prompt-card:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }
    
        .prompt-card-header {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            max-height: 3em;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    
        .prompt-card-negative {
            font-size: 11px;
            color: var(--error);
            max-height: 2em;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    
        .prompt-card-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
    
        .prompt-card-actions {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }
    
        /* Models Tab Grid (NEW) */
        .models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--space-lg);
        }
    
        .models-column h4 {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-secondary);
            margin-bottom: var(--space-sm);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 4px;
        }
    
        .model-item {
            font-size: 12px;
            padding: 4px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
        }
    
        /* Settings Sections (NEW) */
        .settings-section {
            padding: var(--space-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
            background: var(--bg-tertiary);
        }
    
        .settings-section h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
        }
    
        .settings-item {
            padding: 6px 0;
        }
    
    
        /* ===== SCROLLBAR ===== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
    
        ::-webkit-scrollbar-track {
            background: transparent;
        }
    
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
    
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    
        /* ===== TABS (Repeated but kept for completeness) ===== */
        .tabs-list {
            display: flex;
            gap: var(--space-xs);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: var(--space-lg);
        }
    
        .tabs-trigger {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all var(--transition-fast);
            border-bottom: 2px solid transparent;
        }
    
        .tabs-trigger:hover {
            color: var(--text-primary);
        }
    
        .tabs-trigger.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
        }
    
        /* ===== CHECKBOX & RADIO (Kept for completeness) ===== */
        input[type="checkbox"],
        input[type="radio"] {
            width: 18px;
            height: 18px;
            margin-right: var(--space-sm);
            cursor: pointer;
            accent-color: var(--accent-primary);
        }
    
        .checkbox-label,
        .radio-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: var(--space-sm);
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }
    
        .checkbox-label:hover,
        .radio-label:hover {
            background: rgba(255, 255, 255, 0.02);
        }
    
        /* ===== RANGE SLIDER (Kept for completeness) ===== */
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: var(--radius-full);
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
    
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }
    
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
            box-shadow: var(--shadow-sm);
        }
    
        /* ===== UTILITIES (Kept for completeness) ===== */
        .w-full {
            width: 100%;
        }
    
        .hidden {
            display: none !important;
        }
    
        .text-center {
            text-align: center;
        }
    
        .text-right {
            text-align: right;
        }
    
        .mt-0 {
            margin-top: 0;
        }
    
        .mt-1 {
            margin-top: var(--space-xs);
        }
    
        .mt-2 {
            margin-top: var(--space-sm);
        }
    
        .mt-3 {
            margin-top: var(--space-md);
        }
    
        .mt-4 {
            margin-top: var(--space-lg);
        }
    
        .mb-0 {
            margin-bottom: 0;
        }
    
        .mb-1 {
            margin-bottom: var(--space-xs);
        }
    
        .mb-2 {
            margin-bottom: var(--space-sm);
        }
    
        .mb-3 {
            margin-bottom: var(--space-md);
        }
    
        .mb-4 {
            margin-bottom: var(--space-lg);
        }
    
        .p-0 {
            padding: 0;
        }
    
        .p-1 {
            padding: var(--space-xs);
        }
    
        .p-2 {
            padding: var(--space-sm);
        }
    
        .p-3 {
            padding: var(--space-md);
        }
    
        .p-4 {
            padding: var(--space-lg);
        }
    
        .text-gradient {
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    
        .glass {
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
        }
    
        /* ===== RESPONSIVE (Kept for completeness) ===== */
        @media (max-width: 1200px) {
            .controls-grid {
                grid-template-columns: 1fr;
                /* Stack controls and preview */
            }
    
            .main-content {
                flex-direction: column;
            }
    
            .tab-bar,
            .app-header {
                margin-left: 0;
            }
    
            .stats-container {
                position: relative;
                /* Make it flow with the content on small screens */
                width: 100%;
                top: auto;
                left: auto;
                margin-bottom: var(--space-md);
                padding: var(--space-sm);
                flex-direction: row;
                flex-wrap: wrap;
                height: auto;
            }
    
            .stats-container .stat-bar {
                width: calc(50% - 4px);
                /* Two columns in the stats bar on mobile */
            }
        }
    
        @media (max-width: 768px) {
            .app-container {
                padding: var(--space-sm);
            }
    
            .tab-bar {
                flex-direction: column;
                width: 100%;
            }
    
            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
    
            .stats-container .stat-bar {
                width: 100%;
            }
        }
    
        /* ===== ANIMATIONS (Kept for completeness) ===== */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
    
            to {
                opacity: 1;
            }
        }
    
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
    
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
    
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    
        .fade-in {
            animation: fadeIn var(--transition-base);
        }
    
        .slide-up {
            animation: slideUp var(--transition-base);
        }
    
        .slide-down {
            animation: slideDown var(--transition-base);
        }
    </style>

    <!-- React Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <div id="root"></div>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function App() {
            // --- State Definitions ---
            const [connected, setConnected] = useState(false);
            const [serverUrl, setServerUrl] = useState('/comfyui');
            const [ws, setWs] = useState(null);
            const [facelessDetected, setFacelessDetected] = useState(false);
            const [generating, setGenerating] = useState(false);
            const [progress, setProgress] = useState(0);
            const [progressText, setProgressText] = useState('');
            const [generatedImages, setGeneratedImages] = useState([]);
            const [errorMessage, setErrorMessage] = useState('');
            const [errorDetails, setErrorDetails] = useState('');
            const [selectedImage, setSelectedImage] = useState(null);
            const [latestImage, setLatestImage] = useState(null); // New State for Preview
            const [openAccordions, setOpenAccordions] = useState(['presets', 'basic', 'model', 'loras', 'face-swap', 'upscale', 'video', 'embeddings']);
            const [openGgufAccordions, setOpenGgufAccordions] = useState(['gguf-model', 'gguf-prompts', 'gguf-sampling']);
            const [activeTab, setActiveTab] = useState('generate');

            // GGUF Generation states
            const [ggufPrompt, setGgufPrompt] = useState('');
            const [ggufNegativePrompt, setGgufNegativePrompt] = useState('');
            const [ggufWidth, setGgufWidth] = useState(512);
            const [ggufHeight, setGgufHeight] = useState(512);
            const [ggufSteps, setGgufSteps] = useState(20);
            const [ggufCfgScale, setGgufCfgScale] = useState(7);
            const [ggufSeed, setGgufSeed] = useState(-1);
            const [ggufBatchSize, setGgufBatchSize] = useState(1);
            const [ggufDenoise, setGgufDenoise] = useState(1.0);
            const [ggufControlAfterGenerate, setGgufControlAfterGenerate] = useState('fixed');
            const [ggufWatermarkText, setGgufWatermarkText] = useState('(c) 2025 AWDigitalworld Limited');
            const [selectedGgufClipType, setSelectedGgufClipType] = useState('stable_diffusion');
            const [selectedGgufDevice, setSelectedGgufDevice] = useState('default');
            const [selectedGgufVae, setSelectedGgufVae] = useState('');
            const [selectedGgufClipModel, setSelectedGgufClipModel] = useState('');
            const [selectedGgufSampler, setSelectedGgufSampler] = useState('');
            const [selectedGgufScheduler, setSelectedGgufScheduler] = useState('');
            const [ggufSelectedLoras, setGgufSelectedLoras] = useState([]);
            const [ggufGenerating, setGgufGenerating] = useState(false);
            const [availableGgufClipModels, setAvailableGgufClipModels] = useState([]);
            const [sidebarCollapsed, setSidebarCollapsed] = useState(false);

            const [prompt, setPrompt] = useState('');
            const [negativePrompt, setNegativePrompt] = useState('');
            const [width, setWidth] = useState(512);
            const [height, setHeight] = useState(512);
            const [steps, setSteps] = useState(20);
            const [cfgScale, setCfgScale] = useState(7);
            const [seed, setSeed] = useState(-1);

            const [availableModels, setAvailableModels] = useState([]);
            const [selectedModel, setSelectedModel] = useState('');
            const [availableVaes, setAvailableVaes] = useState([]);
            const [selectedVae, setSelectedVae] = useState('');
            const [availableSamplers, setAvailableSamplers] = useState([]);
            const [selectedSampler, setSelectedSampler] = useState('');
            const [availableSchedulers, setAvailableSchedulers] = useState([]);
            const [selectedScheduler, setSelectedScheduler] = useState('');
            const [availableUpscalers, setAvailableUpscalers] = useState([]);
            const [upscaleModel, setUpscaleModel] = useState('');
            const [upscaleEnabled, setUpscaleEnabled] = useState(false);
            const [upscaleFactor, setUpscaleFactor] = useState(2);

            const [selectedLoras, setSelectedLoras] = useState([]);
            const [availableLoras, setAvailableLoras] = useState([]);

            // Watermark toggle for persona-specific watermarking. When enabled
            // and the AWB persona is selected, generated images/videos will
            // include a watermark code in their metadata.  The overlay will
            // display in the gallery.  This preference is persisted.
            const [watermarkEnabled, setWatermarkEnabled] = useState(() => {
                try {
                    return JSON.parse(localStorage.getItem('ai_watermark_enabled')) || false;
                } catch {
                    return false;
                }
            });

            // === Persona ===
            // Define personas with associated prompts and styling.  Currently
            // supports 'default' and 'awb' (Andrew & Wendy Bella).  The AWB
            // persona comes with preconfigured prompts and a luxury
            // gold/black aesthetic.
            const awbPrompts = [
                {
                    prompt:
                        'Andrew Corbett and Wendy Bella Corbett as high-fashion elite power couple, standing confidently in couture evening wear, ultra-realistic photography, luxury cinematic lighting, Vogue editorial style, soft rim light, 85mm lens, shallow depth of field, professional studio quality, emotional connection, elegance and dominance.',
                    negativePrompt:
                        'blurry, low detail, distorted anatomy, deformed hands, watermark, cropped, bad lighting',
                    tags: ['AWB', 'master', 'couple', 'power'],
                },
                {
                    prompt:
                        'Andrew and Wendy Bella in cinematic luxury wedding scene, standing before cathedral altar, soft golden sunlight filtering through stained glass, emotional romantic gaze, bridal couture gown, tailored groom suit, cinematic realism, shallow focus, ultra-detailed textures, film-like colour grading.',
                    negativePrompt:
                        'blurry, low detail, distorted anatomy, deformed hands, watermark, cropped, bad lighting',
                    tags: ['AWB', 'wedding', 'hero', 'scene'],
                },
                {
                    prompt:
                        'Ultra-cinematic love story scene of Andrew and Wendy Bella embracing on moonlit terrace, slow motion, emotional intensification, dynamic dolly camera movement, ARRI ALEXA lighting simulation, professional colour grading.',
                    negativePrompt:
                        'blurry, low detail, distorted anatomy, deformed hands, watermark, cropped, bad lighting',
                    tags: ['AWB', 'film', 'love story'],
                },
                {
                    prompt:
                        'Andrew & Wendy Bella photographed for global fashion magazine, sophisticated and commanding posture, luxury couture wardrobe, editorial glamour lighting, cinematic tone, minimal background, Vogue-inspired frame.',
                    negativePrompt:
                        'blurry, low detail, distorted anatomy, deformed hands, watermark, cropped, bad lighting',
                    tags: ['AWB', 'editorial', 'fashion'],
                },
            ];

            // Selected persona state.  Default persona uses standard prompts.
            const [selectedPersona, setSelectedPersona] = useState(() => {
                try {
                    return localStorage.getItem('ai_selected_persona') || 'default';
                } catch {
                    return 'default';
                }
            });

            // AWB campaign definitions referencing the AWB prompts above.  Each
            // campaign provides a name and the associated prompt/negative prompt
            // from the AWB persona.  These can be triggered in the Projects tab
            // to quickly set up scenes consistent with the manual.
            const awbCampaigns = [
                {
                    name: 'Wedding Campaign',
                    description: 'Generate luxury wedding scenes for Andrew & Wendy Bella',
                    prompt: awbPrompts[1].prompt,
                    negative: awbPrompts[1].negativePrompt,
                },
                {
                    name: 'Cinematic Love Story',
                    description: 'Create a cinematic love story with dynamic camera movements',
                    prompt: awbPrompts[2].prompt,
                    negative: awbPrompts[2].negativePrompt,
                },
                {
                    name: 'Fashion Editorial',
                    description: 'Shoot editorial portraits for a global fashion magazine',
                    prompt: awbPrompts[3].prompt,
                    negative: awbPrompts[3].negativePrompt,
                },
            ];

            const useCampaign = (camp) => {
                setPrompt(camp.prompt);
                setNegativePrompt(camp.negative || '');
                // Optionally ensure persona negative prompt is applied
            };

            // Placeholder function for future social account integration.  When
            // called it will simply notify the user that integration is not yet
            // implemented.  In future, this could fetch data from a server or
            // external API to display account information.
            const checkSocial = (platform) => {
                setErrorMessage('Integration Pending');
                setErrorDetails(`Future API integration for ${platform} will fetch data for the specified username.`);
            };

            // Prompt library: stores previously used or userâ€‘added prompts.  Each entry
            // can include a main prompt and an optional negative prompt.  The library
            // is persisted to localStorage so it survives refreshes.
            const [promptLibrary, setPromptLibrary] = useState(() => {
                try {
                    const saved = localStorage.getItem('ai_studio_prompts');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return parsed.map(p => ({ ...p, tags: p.tags || suggestTags(p.prompt) }));
                    }
                    return [];
                } catch (e) {
                    return [];
                }
            });

            // Persist prompt library to localStorage whenever it changes
            useEffect(() => {
                try {
                    localStorage.setItem('ai_studio_prompts', JSON.stringify(promptLibrary));
                } catch (e) {
                    // ignore
                }
            }, [promptLibrary]);

            // Add the current prompt and negative prompt to the library.  If an
            // identical entry already exists it will still be prepended again,
            // ensuring the most recent usage appears first.
            const addCurrentPromptToLibrary = () => {
                if (!prompt.trim()) return;
                const tags = suggestTags(prompt);
                setPromptLibrary(prev => [
                    { prompt: prompt, negativePrompt: negativePrompt, tags },
                    ...prev
                ]);
            };

            // CRUD helpers for prompt library
            const addNewPrompt = () => {
                const newPromptText = window.prompt('Enter prompt:');
                if (!newPromptText) return;
                const newNegative = window.prompt('Enter negative prompt (optional):') || '';
                const tagInput = window.prompt('Enter tags (comma-separated, optional):') || '';
                let tags;
                if (tagInput && tagInput.trim() !== '') {
                    tags = tagInput.split(',').map(t => t.trim()).filter(Boolean);
                } else {
                    tags = suggestTags(newPromptText);
                }
                setPromptLibrary(prev => [
                    { prompt: newPromptText, negativePrompt: newNegative, tags },
                    ...prev
                ]);
            };
            const editPromptInLibrary = (index) => {
                const item = promptLibrary[index];
                if (!item) return;
                const newPromptText = window.prompt('Edit prompt:', item.prompt);
                if (newPromptText === null) return; // cancelled
                const newNegativeText = window.prompt('Edit negative prompt (optional):', item.negativePrompt || '') || '';
                const newTagsInput = window.prompt('Edit tags (comma-separated):', (item.tags || []).join(', ')) || '';
                let tags = [];
                if (newTagsInput.trim() !== '') {
                    tags = newTagsInput.split(',').map(t => t.trim()).filter(Boolean);
                }
                setPromptLibrary(prev => prev.map((p, i) => i === index ? { ...p, prompt: newPromptText, negativePrompt: newNegativeText, tags } : p));
            };
            const deletePromptFromLibrary = (index) => {
                if (!window.confirm('Delete this prompt?')) return;
                setPromptLibrary(prev => prev.filter((_, i) => i !== index));
            };

            // Load GGUF models from Electron API or available model list
            useEffect(() => {
                async function loadGguf() {
                    try {
                        if (window.electronAPI && window.electronAPI.getGgufModels) {
                            const ggufs = await window.electronAPI.getGgufModels();
                            setAvailableGgufModels(ggufs || []);
                            if (ggufs && ggufs.length > 0 && !selectedGgufModel) {
                                setSelectedGgufModel(ggufs[0]);
                            }
                        } else {
                            const ggufs = (availableModels || []).filter(m => typeof m === 'string' && m.toLowerCase().endsWith('.gguf'));
                            setAvailableGgufModels(ggufs);
                            if (ggufs.length > 0 && !selectedGgufModel) {
                                setSelectedGgufModel(ggufs[0]);
                            }
                        }
                    } catch (e) {
                        console.error('Failed to load gguf models', e);
                    }
                }
                loadGguf();
            }, [availableModels]);

            // Load and categorize models from Electron API or fallback categorization
            useEffect(() => {
                async function loadModels() {
                    try {
                        if (window.electronAPI && window.electronAPI.listModels) {
                            const modelsMap = await window.electronAPI.listModels();
                            setModelsByType(modelsMap || {});
                        } else {
                            const categories = {};
                            const addCat = (cat, item) => {
                                if (!categories[cat]) categories[cat] = [];
                                categories[cat].push(item);
                            };
                            (availableModels || []).forEach(m => {
                                if (!m) return;
                                const name = m.toLowerCase();
                                if (name.includes('wan')) {
                                    addCat('Wan', m);
                                } else if (name.endsWith('.gguf')) {
                                    addCat('GGUF', m);
                                } else if (name.includes('flux')) {
                                    addCat('Flux', m);
                                } else if (name.includes('sdxl')) {
                                    addCat('SDXL', m);
                                } else if (name.includes('sd')) {
                                    addCat('SD', m);
                                } else if (name.includes('style')) {
                                    addCat('Styles', m);
                                } else {
                                    addCat('Other', m);
                                }
                            });
                            // Add GGUF models to a separate category
                            (availableGgufModels || []).forEach(m => {
                                addCat('GGUF', m);
                            });
                            // Add embeddings into their own category
                            (availableEmbeddings || []).forEach(emb => {
                                addCat('Embeddings', emb);
                            });
                            setModelsByType(categories);
                        }
                    } catch (e) {
                        console.error('Failed to load models list', e);
                        setModelsByType({});
                    }
                }
                loadModels();
            }, [availableModels, availableGgufModels]);

            const [faceSwapEnabled, setFaceSwapEnabled] = useState(false);
            const [faceRestoreEnabled, setFaceRestoreEnabled] = useState(true);
            const [faceSwapImage, setFaceSwapImage] = useState(null);
            const [faceSwapImagePreview, setFaceSwapImagePreview] = useState(null);


            const faceUploadRef = useRef(null);

            // === NEW FEATURES STATE ===
            // Embeddings
            const [availableEmbeddings, setAvailableEmbeddings] = useState([]);

            // === Style Pack ===
            // Allow users to switch between different visual themes (classic, cyberpunk, watercolor).
            const [stylePack, setStylePack] = useState(() => {
                try {
                    return localStorage.getItem('ai_style_pack') || 'classic';
                } catch {
                    return 'classic';
                }
            });
            // Persist style pack and apply class to body whenever it changes.
            useEffect(() => {
                document.body.classList.remove('style-classic', 'style-cyberpunk', 'style-watercolor', 'style-goldblack');
                document.body.classList.add(`style-${stylePack}`);
                try {
                    localStorage.setItem('ai_style_pack', stylePack);
                } catch {
                    /* ignore */
                }
            }, [stylePack]);

            // Persist watermark preference
            useEffect(() => {
                try {
                    localStorage.setItem('ai_watermark_enabled', JSON.stringify(watermarkEnabled));
                } catch {
                    /* ignore */
                }
            }, [watermarkEnabled]);

            // Persist social usernames whenever they change
            useEffect(() => {
                try {
                    localStorage.setItem('ai_insta_username', instagramUsername);
                } catch {
                    /* ignore */
                }
            }, [instagramUsername]);
            useEffect(() => {
                try {
                    localStorage.setItem('ai_facebook_username', facebookUsername);
                } catch {
                    /* ignore */
                }
            }, [facebookUsername]);
            useEffect(() => {
                try {
                    localStorage.setItem('ai_x_username', xUsername);
                } catch {
                    /* ignore */
                }
            }, [xUsername]);

            // Persist selected persona and automatically inject persona prompts and
            // theme when switching personas.  When the AWB persona is selected
            // we set the style pack to goldblack (unless already goldblack) and
            // merge the AWB prompts into the prompt library if they are not
            // already present.  Reverting to the default persona does not
            // remove AWB prompts but keeps them available for future use.
            useEffect(() => {
                try {
                    localStorage.setItem('ai_selected_persona', selectedPersona);
                } catch {
                    /* ignore */
                }
                if (selectedPersona === 'awb') {
                    // Apply goldblack style automatically
                    if (stylePack !== 'goldblack') {
                        setStylePack('goldblack');
                    }
                    // Merge AWB prompts
                    setPromptLibrary((prev) => {
                        const updated = [...prev];
                        awbPrompts.forEach((item) => {
                            if (!updated.some((p) => p.prompt === item.prompt)) {
                                updated.push(item);
                            }
                        });
                        return updated;
                    });
                }
            }, [selectedPersona]);

            // === Video editing states ===
            const [videoTrimStart, setVideoTrimStart] = useState(0);
            const [videoTrimEnd, setVideoTrimEnd] = useState(0);
            const [videoAudioFile, setVideoAudioFile] = useState(null);
            const [videoAudioPreview, setVideoAudioPreview] = useState(null);

            // === Smart scheduling states ===
            const [maxConcurrency, setMaxConcurrency] = useState(() => {
                try {
                    const saved = localStorage.getItem('ai_max_concurrency');
                    return saved ? parseInt(saved) : 1;
                } catch {
                    return 1;
                }
            });
            const [activeTasks, setActiveTasks] = useState(0);
            useEffect(() => {
                try {
                    localStorage.setItem('ai_max_concurrency', String(maxConcurrency));
                } catch {
                    /* ignore */
                }
            }, [maxConcurrency]);

            // === Workflow presets ===
            const [workflowPresets, setWorkflowPresets] = useState(() => {
                try {
                    const saved = localStorage.getItem('ai_workflow_presets');
                    return saved ? JSON.parse(saved) : [];
                } catch {
                    return [];
                }
            });
            useEffect(() => {
                try {
                    localStorage.setItem('ai_workflow_presets', JSON.stringify(workflowPresets));
                } catch {
                    /* ignore */
                }
            }, [workflowPresets]);

            // Image-to-Image
            const [img2imgEnabled, setImg2imgEnabled] = useState(false);
            const [img2imgImage, setImg2imgImage] = useState(null);
            const [img2imgImagePreview, setImg2imgImagePreview] = useState(null);
            const [img2imgStrength, setImg2imgStrength] = useState(0.75);
            const img2imgUploadRef = useRef(null);

            // Video generation states
            const [videoMode, setVideoMode] = useState('t2v'); // t2v = text-to-video, i2v = image-to-video
            const [videoLength, setVideoLength] = useState(4); // seconds of output video
            const [frameRate, setFrameRate] = useState(24); // frames per second
            const [i2vImage, setI2vImage] = useState(null);
            const [i2vImagePreview, setI2vImagePreview] = useState(null);
            const i2vUploadRef = useRef(null);
            const [videoResults, setVideoResults] = useState([]);
            const [videoProgress, setVideoProgress] = useState(0);
            const [videoGenerating, setVideoGenerating] = useState(false);
            const [videoError, setVideoError] = useState('');

            // Video resolution and audio
            // Allow users to specify custom width and height for generated videos and optional narration text.
            const [videoWidth, setVideoWidth] = useState(832);
            const [videoHeight, setVideoHeight] = useState(480);
            const [audioPrompt, setAudioPrompt] = useState('');

            // Generation queue. Each entry has { id, type, prompt, status, error? }.
            const [generationQueue, setGenerationQueue] = useState([]);

            // GGUF and model listing
            const [availableGgufModels, setAvailableGgufModels] = useState([]);
            const [selectedGgufModel, setSelectedGgufModel] = useState('');
            const [availableGgufUnetModels, setAvailableGgufUnetModels] = useState([]);
            const [selectedGgufUnetModel, setSelectedGgufUnetModel] = useState('');
            const [modelsByType, setModelsByType] = useState({});

            // === Prompt Tagging and Search ===
            // Stop words list for simple tag suggestions
            const stopwords = ['a', 'an', 'the', 'and', 'or', 'with', 'without', 'for', 'to', 'of', 'in', 'on', 'at', 'from', 'by'];
            // Suggest tags by extracting first few significant words
            const suggestTags = (text) => {
                if (!text) return [];
                return text
                    .toLowerCase()
                    .split(/[^a-z0-9]+/)
                    .filter((word) => word && !stopwords.includes(word))
                    .slice(0, 3);
            };

            // Search query and tag filter states for prompt library
            const [searchQuery, setSearchQuery] = useState('');
            const [selectedTag, setSelectedTag] = useState(null);

            // Pagination for prompt library card view
            const promptsPerPage = 25;
            const [promptPage, setPromptPage] = useState(1);
            useEffect(() => {
                // Reset page when filters change
                setPromptPage(1);
            }, [searchQuery, selectedTag, promptLibrary]);

            // Voice recognition and command handling
            const [listening, setListening] = useState(false);
            const recognitionRef = useRef(null);

            const toggleListening = () => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    alert('Voice recognition not supported in this browser.');
                    return;
                }
                if (listening) {
                    if (recognitionRef.current) recognitionRef.current.stop();
                    setListening(false);
                } else {
                    if (!recognitionRef.current) {
                        const recognition = new SpeechRecognition();
                        recognition.lang = 'en-US';
                        recognition.interimResults = false;
                        recognition.continuous = false;
                        recognition.onresult = (event) => {
                            const transcript = event.results[0][0].transcript.trim().toLowerCase();
                            handleVoiceCommand(transcript);
                        };
                        recognition.onerror = (err) => {
                            console.error('Voice recognition error:', err);
                            setListening(false);
                        };
                        recognition.onend = () => {
                            setListening(false);
                        };
                        recognitionRef.current = recognition;
                    }
                    recognitionRef.current.start();
                    setListening(true);
                }
            };

            const handleVoiceCommand = (command) => {
                if (!command) return;
                try {
                    if (command.startsWith('generate')) {
                        startGeneration();
                    } else if (command.startsWith('add prompt')) {
                        const text = command.replace('add prompt', '').trim();
                        if (text) {
                            setPrompt(text);
                            addCurrentPromptToLibrary();
                        }
                    } else if (command.startsWith('search')) {
                        const text = command.replace('search', '').trim();
                        setSearchQuery(text);
                    }
                } catch (e) {
                    console.error('Voice command error:', e);
                }
            };

            // --- System Stats ---
            // Stats values range from 0 to 100 (percentage) where applicable. Temperature can be any numeric value.
            const [stats, setStats] = useState({ cpu: null, ram: null, gpu: null, vram: null, temp: null });

            // Server configuration fields. These mirror the current serverUrl but allow editing host and port in the settings.
            const [serverHost, setServerHost] = useState('');
            const [serverPort, setServerPort] = useState('');
            useEffect(() => {
                try {
                    const urlObj = new URL(serverUrl);
                    setServerHost(urlObj.hostname);
                    setServerPort(urlObj.port);
                } catch {
                    // If parsing fails, attempt to extract host/port manually
                    const parts = serverUrl.replace(/^https?:\/\//, '').split(':');
                    setServerHost(parts[0] || '');
                    setServerPort(parts[1] || '');
                }
            }, [serverUrl]);

            const applyServerConfig = () => {
                const portSegment = serverPort ? `:${serverPort}` : '';
                const newUrl = `http://${serverHost}${portSegment}`;
                setServerUrl(newUrl);
                connectToServer(newUrl);
            };
            useEffect(() => {
                const fetchStats = async () => {
                    try {
                        // Use server API endpoint (which proxies to server's system stats)
                        const resp = await fetch('/api/system-stats');

                        if (resp.ok) {
                            const data = await resp.json();

                            // Server API returns: { cpu, ram, gpu: [{...}], vram, temp }
                            let cpuPercent = data.cpu ?? null;
                            let ramPercent = data.ram ?? null;
                            let gpuPercent = null;
                            let vramPercent = data.vram ?? null;
                            let tempValue = data.temp ?? null;

                            // If gpu array exists, use first GPU's utilization
                            if (data.gpu && data.gpu.length > 0) {
                                const gpu = data.gpu[0];
                                if (gpu.utilization !== null) {
                                    gpuPercent = Math.round(gpu.utilization);
                                }
                                if (gpu.memory_percent !== null) {
                                    vramPercent = gpu.memory_percent;
                                }
                                if (gpu.temperature !== null) {
                                    tempValue = gpu.temperature;
                                }
                            }

                            setStats({
                                cpu: cpuPercent,
                                ram: ramPercent,
                                gpu: gpuPercent,
                                vram: vramPercent,
                                temp: tempValue
                            });
                        } else {
                            // API error, set stats to null
                            setStats({
                                cpu: null,
                                ram: null,
                                gpu: null,
                                vram: null,
                                temp: null
                            });
                        }
                    } catch (err) {
                        // Silently fail - system stats are optional
                        console.log('System stats unavailable:', err.message);
                        setStats({
                            cpu: null,
                            ram: null,
                            gpu: null,
                            vram: null,
                            temp: null
                        });
                    }
                };

                fetchStats();
                const interval = setInterval(fetchStats, 2000); // Update every 2 seconds
                return () => clearInterval(interval);
            }, []);
            // Inpainting
            const [inpaintEnabled, setInpaintEnabled] = useState(false);
            const [inpaintImage, setInpaintImage] = useState(null);
            const [inpaintImagePreview, setInpaintImagePreview] = useState(null);
            const [inpaintStrength, setInpaintStrength] = useState(1.0);
            const [isDrawingMask, setIsDrawingMask] = useState(false);
            const [brushSize, setBrushSize] = useState(20);
            const inpaintUploadRef = useRef(null);
            const canvasRef = useRef(null);
            // Renamed batch size state to avoid duplicate declaration issues.  See error logs.
            const [batchSizeValue, setBatchSizeValue] = useState(1);

            // --- Social Usernames ---
            // Store usernames for Instagram, Facebook and X (Twitter).  Values
            // persist across sessions via localStorage.  These will be used for
            // future API integrations to fetch account data.
            const [instagramUsername, setInstagramUsername] = useState(() => {
                try {
                    return localStorage.getItem('ai_insta_username') || '';
                } catch {
                    return '';
                }
            });
            const [facebookUsername, setFacebookUsername] = useState(() => {
                try {
                    return localStorage.getItem('ai_facebook_username') || '';
                } catch {
                    return '';
                }
            });
            const [xUsername, setXUsername] = useState(() => {
                try {
                    return localStorage.getItem('ai_x_username') || '';
                } catch {
                    return '';
                }
            });

            // Fields for creating a new scheduled post
            const [newPostPlatform, setNewPostPlatform] = useState('Instagram');
            const [newPostDate, setNewPostDate] = useState('');
            const [newPostTime, setNewPostTime] = useState('');
            const [newPostContent, setNewPostContent] = useState('');

            // --- Scheduled Posts for Marketing ---
            // List of scheduled posts. Each entry contains id, platform, datetime,
            // content and status (pending or posted). Persisted to localStorage.
            const [scheduledPosts, setScheduledPosts] = useState(() => {
                try {
                    const saved = localStorage.getItem('ai_scheduled_posts');
                    return saved ? JSON.parse(saved) : [];
                } catch {
                    return [];
                }
            });
            // Save scheduled posts whenever they change
            useEffect(() => {
                try {
                    localStorage.setItem('ai_scheduled_posts', JSON.stringify(scheduledPosts));
                } catch {
                    /* ignore */
                }
            }, [scheduledPosts]);

            const addScheduledPost = (post) => {
                setScheduledPosts(prev => [...prev, { ...post, id: Date.now(), status: 'pending' }]);
            };
            const deleteScheduledPost = (id) => {
                setScheduledPosts(prev => prev.filter(p => p.id !== id));
            };
            const markScheduledPost = (id) => {
                setScheduledPosts(prev => prev.map(p => p.id === id ? { ...p, status: p.status === 'pending' ? 'posted' : 'pending' } : p));
            };

            // Schedules a new post when the marketing form is submitted. It verifies that
            // a date, time and non-empty content are provided, then constructs
            // a human-readable datetime string and adds the new post to the
            // scheduledPosts list. Afterwards, it resets the form fields.
            const handleSchedulePost = () => {
                const date = newPostDate;
                const time = newPostTime;
                const content = newPostContent.trim();
                if (!date || !time || !content) {
                    return;
                }
                const datetime = `${date} ${time}`;
                addScheduledPost({ platform: newPostPlatform, datetime, content });
                setNewPostDate('');
                setNewPostTime('');
                setNewPostContent('');
            };

            // --- Project Management ---
            // List of user projects. Each project represents a workspace that can hold its own presets and outputs.
            const [projects, setProjects] = useState(() => {
                try {
                    const saved = localStorage.getItem('ai_studio_projects');
                    return saved ? JSON.parse(saved) : [];
                } catch {
                    return [];
                }
            });
            // Currently active project name
            const [currentProject, setCurrentProject] = useState(null);
            // Input value for creating a new project
            const [newProjectName, setNewProjectName] = useState('');
            useEffect(() => {
                localStorage.setItem('ai_studio_projects', JSON.stringify(projects));
            }, [projects]);
            const addProject = () => {
                const name = newProjectName.trim();
                if (!name) return;
                if (!projects.includes(name)) {
                    setProjects(prev => [...prev, name]);
                    setCurrentProject(name);
                }
                setNewProjectName('');
            };
            const deleteProject = (name) => {
                setProjects(prev => prev.filter(p => p !== name));
                if (currentProject === name) {
                    setCurrentProject(null);
                }
            };
            const selectProject = (name) => {
                setCurrentProject(name);
            };

            // --- LoRA Training ---
            const [loraTrainingDataset, setLoraTrainingDataset] = useState(null);
            const [loraTrainingModel, setLoraTrainingModel] = useState('');
            const [loraTrainingSteps, setLoraTrainingSteps] = useState(200);
            const [loraTrainingLr, setLoraTrainingLr] = useState(0.0001);
            const [loraTrainingStatus, setLoraTrainingStatus] = useState('');
            const handleLoraDatasetUpload = (e) => {
                const file = e.target.files[0];
                setLoraTrainingDataset(file || null);
            };
            const trainLora = async () => {
                if (!loraTrainingDataset || !loraTrainingModel) {
                    setLoraTrainingStatus('Please select dataset and base model');
                    return;
                }
                try {
                    setLoraTrainingStatus('Uploading dataset...');
                    const formData = new FormData();
                    formData.append('dataset', loraTrainingDataset);
                    formData.append('model', loraTrainingModel);
                    formData.append('steps', loraTrainingSteps);
                    formData.append('lr', loraTrainingLr);
                    const res = await fetch(`${serverUrl}/train-lora`, {
                        method: 'POST',
                        body: formData
                    });
                    if (!res.ok) throw new Error('Training request failed');
                    const data = await res.json();
                    setLoraTrainingStatus(data.message || 'Training started');
                } catch (err) {
                    console.error('LoRA training error:', err);
                    setLoraTrainingStatus('Training failed');
                }
            };

            // Simple toggle for enabling/disabling LoRA in the Manager. Adds or removes from selectedLoras with default strength.
            const toggleLora = (name) => {
                setSelectedLoras(prev => {
                    const exists = prev.find(l => l.name === name);
                    if (exists) {
                        return prev.filter(l => l.name !== name);
                    } else {
                        return [...prev, { name, strength: 0.8 }];
                    }
                });
            };

            // --- Caption Generation ---
            const [captionImage, setCaptionImage] = useState(null);
            const [captionImagePreview, setCaptionImagePreview] = useState(null);
            const [captionTags, setCaptionTags] = useState([]);
            const [captionDescription, setCaptionDescription] = useState('');
            const handleCaptionUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setCaptionImage(file);
                    setCaptionImagePreview(URL.createObjectURL(file));
                }
            };
            const generateCaption = async () => {
                if (!captionImage) return;
                try {
                    const formData = new FormData();
                    formData.append('image', captionImage);
                    const res = await fetch(`${serverUrl}/generate-caption`, {
                        method: 'POST',
                        body: formData
                    });
                    if (!res.ok) throw new Error('Caption request failed');
                    const data = await res.json();
                    setCaptionTags(data.tags || []);
                    setCaptionDescription(data.description || '');
                } catch (err) {
                    console.error('Caption generation failed:', err);
                    setCaptionTags([]);
                    setCaptionDescription('Failed to generate caption');
                }
            };

            // --- VRAM Estimation ---
            const totalVram = 12;
            const estimateVramUsage = (modelName) => {
                if (!modelName) return 0;
                const lower = modelName.toLowerCase();
                let usage = 0;
                if (lower.includes('sdxl')) {
                    usage = (lower.includes('fp8') || lower.includes('nf4') || lower.includes('gguf')) ? 4 : 8;
                } else if (lower.includes('sd')) {
                    usage = (lower.includes('fp8') || lower.includes('nf4') || lower.includes('gguf')) ? 2 : 4;
                } else if (lower.includes('flux') || lower.includes('wan')) {
                    usage = (lower.includes('fp8') || lower.includes('nf4') || lower.includes('gguf')) ? 4 : 8;
                } else {
                    usage = 2;
                }
                return usage;
            };
            const vramEstimate = React.useMemo(() => {
                let usage = 0;
                usage += estimateVramUsage(selectedModel);
                usage += estimateVramUsage(selectedGgufModel);
                if (selectedLoras && selectedLoras.length > 0) usage += selectedLoras.length * 0.5;
                if (upscaleEnabled) usage += 1;
                if (faceSwapEnabled) usage += 1;
                if (img2imgEnabled) usage += 1;
                if (inpaintEnabled) usage += 1;
                return usage;
            }, [selectedModel, selectedGgufModel, selectedLoras, upscaleEnabled, faceSwapEnabled, img2imgEnabled, inpaintEnabled]);

            // Gallery pagination
            const [galleryPage, setGalleryPage] = useState(1);
            const imagesPerPage = 40;
            // Reset page when gallery changes
            useEffect(() => {
                setGalleryPage(1);
            }, [generatedImages]);

            // --- Effects ---
            const [presets, setPresets] = useState(() => {
                try {
                    const saved = localStorage.getItem('ai_studio_presets');
                    return saved ? JSON.parse(saved) : [];
                } catch (e) {
                    return [];
                }
            });

            useEffect(() => {
                try {
                    const savedImages = localStorage.getItem('ai_studio_images');
                    if (savedImages) {
                        setGeneratedImages(JSON.parse(savedImages));
                        // Restore latest image preview from gallery if available
                        if (JSON.parse(savedImages).length > 0) {
                            setLatestImage(JSON.parse(savedImages)[0].url);
                        }
                    }
                } catch {
                    // ignore
                }
            }, []);

            useEffect(() => {
                localStorage.setItem('ai_studio_presets', JSON.stringify(presets));
            }, [presets]);

            useEffect(() => {
                localStorage.setItem('ai_studio_images', JSON.stringify(generatedImages));
            }, [generatedImages]);

            useEffect(() => {
                if (window.electronAPI) {
                    // Load config from server API
                    window.electronAPI.getConfig().then(config => {
                        setServerUrl(config.comfyuiUrl);
                        if (config.autoConnect) {
                            connectToServer(config.comfyuiUrl);
                        }
                    });
                } else {
                    // Fallback: Server version should always use proxied path
                    const defaultUrl = '/comfyui';
                    setServerUrl(defaultUrl);
                    connectToServer(defaultUrl);
                }
            }, []);

            // --- Helper Functions ---
            const connectToServer = async (url) => {
                try {
                    const modelsRes = await fetch(`${url}/object_info`);
                    const modelsData = await modelsRes.json();

                    // Debug: Log all node types to help find GGUF loaders
                    console.log('=== ComfyUI Node Types ===');
                    console.log('All available node types:', Object.keys(modelsData));
                    console.log('GGUF-related nodes:', Object.keys(modelsData).filter(k => k.toLowerCase().includes('gguf')));
                    console.log('==========================');

                    const hasFaceless = modelsData['FacelessFaceSwap'] || modelsData['FacelessFaceRestore'];
                    setFacelessDetected(!!hasFaceless);

                    if (modelsData.CheckpointLoaderSimple?.input?.required?.ckpt_name) {
                        const models = modelsData.CheckpointLoaderSimple.input.required.ckpt_name[0];
                        setAvailableModels(models);
                        if (models.length > 0 && !selectedModel) setSelectedModel(models[0]);
                        
                        // Set connected to true when models load successfully
                        setConnected(true);
                    }
                    if (modelsData.VAELoader?.input?.required?.vae_name) {
                        const vaes = modelsData.VAELoader.input.required.vae_name[0];
                        setAvailableVaes(vaes);
                        if (vaes.length > 0 && !selectedVae) setSelectedVae(vaes[0]);
                    }
                    if (modelsData.KSampler?.input?.required?.sampler_name) {
                        const samplers = modelsData.KSampler.input.required.sampler_name[0];
                        setAvailableSamplers(samplers);
                        if (samplers.length > 0 && !selectedSampler) setSelectedSampler(samplers[0]);
                    }
                    if (modelsData.KSampler?.input?.required?.scheduler) {
                        const schedulers = modelsData.KSampler.input.required.scheduler[0];
                        setAvailableSchedulers(schedulers);
                        if (schedulers.length > 0 && !selectedScheduler) setSelectedScheduler(schedulers[0]);
                    }
                    if (modelsData.LoraLoader?.input?.required?.lora_name) {
                        const loras = modelsData.LoraLoader.input.required.lora_name[0];
                        setAvailableLoras(loras);
                    }

                    // Load GGUF models from all possible locations
                    let allGgufModels = [];
                    let allGgufUnetModels = [];

                    // Check UNETLoader (unet folder)
                    if (modelsData.UNETLoader?.input?.required?.unet_name) {
                        const unetModels = modelsData.UNETLoader.input.required.unet_name[0] || [];
                        const ggufFromUnet = unetModels.filter(m => m.endsWith('.gguf'));

                        ggufFromUnet.forEach(m => {
                            if (m.endsWith('-unet.gguf')) {
                                allGgufUnetModels.push(m);
                            } else {
                                allGgufModels.push(m);
                            }
                        });
                    }

                    // Check CheckpointLoaderSimple (checkpoints folder) - GGUF models might be here
                    if (modelsData.CheckpointLoaderSimple?.input?.required?.ckpt_name) {
                        const checkpointModels = modelsData.CheckpointLoaderSimple.input.required.ckpt_name[0] || [];
                        const ggufFromCheckpoints = checkpointModels.filter(m => m.endsWith('.gguf'));

                        ggufFromCheckpoints.forEach(m => {
                            if (m.endsWith('-unet.gguf')) {
                                allGgufUnetModels.push(m);
                            } else {
                                allGgufModels.push(m);
                            }
                        });
                    }

                    // Check for any GGUFLoader node types
                    Object.keys(modelsData).forEach(nodeType => {
                        if (nodeType.toLowerCase().includes('gguf')) {
                            const node = modelsData[nodeType];
                            // Check various possible input names
                            ['model_name', 'unet_name', 'ckpt_name', 'model', 'gguf_name'].forEach(inputName => {
                                if (node?.input?.required?.[inputName]) {
                                    const models = node.input.required[inputName][0] || [];
                                    const ggufModels = Array.isArray(models) ? models.filter(m => m.endsWith('.gguf')) : [];

                                    ggufModels.forEach(m => {
                                        if (m.endsWith('-unet.gguf')) {
                                            allGgufUnetModels.push(m);
                                        } else {
                                            allGgufModels.push(m);
                                        }
                                    });
                                }
                            });
                        }
                    });

                    // Remove duplicates
                    allGgufModels = [...new Set(allGgufModels)];
                    allGgufUnetModels = [...new Set(allGgufUnetModels)];

                    console.log('Found GGUF models:', allGgufModels);
                    console.log('Found GGUF UNET models:', allGgufUnetModels);

                    // Set main models (all .gguf models that are NOT -unet)
                    if (allGgufModels.length > 0) {
                        setAvailableGgufModels(allGgufModels);
                        if (!selectedGgufModel) setSelectedGgufModel(allGgufModels[0]);
                    }

                    // Set UNET models (models ending in -unet.gguf)
                    if (allGgufUnetModels.length > 0) {
                        setAvailableGgufUnetModels(allGgufUnetModels);
                        if (!selectedGgufUnetModel) setSelectedGgufUnetModel(allGgufUnetModels[0]);
                    }

                    // Load GGUF CLIP models from clip, clip_vision, and text_encoders folders
                    let allClipModels = [];

                    // Check CLIPLoader (clip folder)
                    if (modelsData.CLIPLoader?.input?.required?.clip_name) {
                        const clipModels = modelsData.CLIPLoader.input.required.clip_name[0] || [];
                        allClipModels = [...allClipModels, ...clipModels];
                    }

                    // Check DualCLIPLoader if it exists (for dual clip setups)
                    if (modelsData.DualCLIPLoader?.input?.required?.clip_name1) {
                        const dualClipModels = modelsData.DualCLIPLoader.input.required.clip_name1[0] || [];
                        allClipModels = [...allClipModels, ...dualClipModels];
                    }

                    // Remove duplicates
                    allClipModels = [...new Set(allClipModels)];

                    if (allClipModels.length > 0) {
                        setAvailableGgufClipModels(allClipModels);
                        if (!selectedGgufClipModel) setSelectedGgufClipModel(allClipModels[0]);
                    }

                    if (modelsData.UpscaleModelLoader?.input?.required?.model_name) {
                        const upscalers = modelsData.UpscaleModelLoader.input.required.model_name[0];
                        setAvailableUpscalers(upscalers);
                        if (upscalers.length > 0 && !upscaleModel) setUpscaleModel(upscalers[0]);


                        // Load embeddings
                        try {
                            const embRes = await fetch(`${url}/embeddings`);
                            const embData = await embRes.json();
                            setAvailableEmbeddings(embData || []);
                        } catch (e) {
                            console.error('Failed to load embeddings:', e);
                        }
                    }

                    const wsUrl = url.replace('http://', 'ws://').replace('https://', 'wss://') + '/ws';
                    const websocket = new WebSocket(wsUrl);

                    websocket.onopen = () => {
                        setConnected(true);
                        setWs(websocket);
                    };

                    websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        if (data.type === 'progress') {
                            const percent = Math.round((data.data.value / data.data.max) * 100);
                            setProgress(percent);
                            setProgressText(`Step ${data.data.value}/${data.data.max}`);
                        }
                        if (data.type === 'executing' && data.data.node === null) {
                            setProgress(100);
                            setProgressText('Complete');
                        }
                        if (data.type === 'result') {
                            const images = data.data.images || [];
                            const withMeta = images.map(img => ({
                                url: `data:image/png;base64,${img.image}`,
                                metadata: img.metadata || {}
                            }));
                            setGeneratedImages(prev => [...withMeta, ...prev]);
                        }
                    };

                    websocket.onerror = () => setConnected(false);
                    websocket.onclose = () => setConnected(false);
                } catch (error) {
                    console.error('Connection error:', error);
                    setConnected(false);
                }
            };

            const toggleAccordion = (name) => {
                setOpenAccordions(prev =>
                    prev.includes(name) ? prev.filter(x => x !== name) : [...prev, name]
                );
            };

            const toggleGgufAccordion = (name) => {
                setOpenGgufAccordions(prev =>
                    prev.includes(name) ? prev.filter(x => x !== name) : [...prev, name]
                );
            };

            const addLora = () => {
                const defaultLora = availableLoras[0] || '';
                setSelectedLoras(prev => [...prev, { name: defaultLora, strength: 0.8 }]);
            };

            const removeLora = (index) => {
                setSelectedLoras(prev => prev.filter((_, i) => i !== index));
            };

            const updateLoraName = (index, name) => {
                setSelectedLoras(prev => prev.map((lora, i) =>
                    i === index ? { ...lora, name } : lora
                ));
            };

            const updateLoraStrength = (index, strength) => {
                setSelectedLoras(prev => prev.map((lora, i) =>
                    i === index ? { ...lora, strength: parseFloat(strength) } : lora
                ));
            };

            const handleFaceUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = () => {
                    setFaceSwapImage(reader.result.split(',')[1]);
                    setFaceSwapImagePreview(reader.result);
                };
                reader.readAsDataURL(file);
            };


            // === NEW FEATURES HANDLERS ===
            const handleImg2ImgUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    setImg2imgImage(file);
                    const reader = new FileReader();
                    reader.onload = (e) => setImg2imgImagePreview(e.target.result);
                    reader.readAsDataURL(file);
                }
            };

            const uploadImg2ImgImage = async (file) => {
                const formData = new FormData();
                formData.append('image', file);
                const response = await fetch(`${serverUrl}/upload/image`, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) throw new Error(`Upload failed: ${response.status}`);
                const result = await response.json();
                return result.subfolder ? `${result.subfolder}/${result.name}` : result.name;
            };

            // Upload an audio file to the server. Returns the filename on the server.
            const uploadAudio = async (file) => {
                const formData = new FormData();
                formData.append('audio', file);
                const response = await fetch(`${serverUrl}/upload/audio`, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) throw new Error(`Audio upload failed: ${response.status}`);
                const result = await response.json();
                return result.subfolder ? `${result.subfolder}/${result.name}` : result.name;
            };

            // Handle local audio file selection and preview for video generation.
            const handleAudioUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                setVideoAudioFile(file);
                const reader = new FileReader();
                reader.onload = (e) => setVideoAudioPreview(e.target.result);
                reader.readAsDataURL(file);
            };

            const handleInpaintUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    setInpaintImage(file);
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setInpaintImagePreview(e.target.result);
                        const img = new Image();
                        img.onload = () => {
                            const canvas = canvasRef.current;
                            if (canvas) {
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                            }
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            const startDrawing = (e) => {
                setIsDrawingMask(true);
                draw(e);
            };

            const stopDrawing = () => setIsDrawingMask(false);

            const draw = (e) => {
                if (!isDrawingMask) return;
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(x, y, brushSize, 0, Math.PI * 2);
                ctx.fill();
            };

            const clearMask = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (inpaintImagePreview) {
                    const img = new Image();
                    img.onload = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                    };
                    img.src = inpaintImagePreview;
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            };

            const getMaskAsImage = () => {
                const canvas = canvasRef.current;
                return new Promise((resolve) => {
                    canvas.toBlob((blob) => {
                        resolve(new File([blob], 'mask.png', { type: 'image/png' }));
                    });
                });
            };

            const uploadInpaintMask = async (maskFile) => {
                const formData = new FormData();
                formData.append('image', maskFile);
                const response = await fetch(`${serverUrl}/upload/image`, {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) throw new Error(`Mask upload failed: ${response.status}`);
                const result = await response.json();
                return result.subfolder ? `${result.subfolder}/${result.name}` : result.name;
            };

            // Handle upload for Image-to-Video mode
            const handleI2vUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                setI2vImage(file);
                const reader = new FileReader();
                reader.onload = (e) => setI2vImagePreview(e.target.result);
                reader.readAsDataURL(file);
            };

            // Generate video using Wan 2.1. Supports text-to-video and image-to-video modes.
            const generateVideo = async () => {
                if (!serverUrl) {
                    alert('Please connect to the server first.');
                    return;
                }
                if (videoMode === 't2v' && !prompt.trim()) {
                    alert('Enter a prompt for text-to-video.');
                    return;
                }
                if (videoMode === 'i2v' && !i2vImage) {
                    alert('Please upload an image for image-to-video.');
                    return;
                }
                setVideoGenerating(true);
                setVideoProgress(0);
                setVideoError('');
                try {
                    // Build payload for video generation, including dimensions and model
                    let payload = {
                        prompt: prompt,
                        negative_prompt: negativePrompt,
                        length: videoLength,
                        fps: frameRate,
                        model: 'wan2.1',
                        width: videoWidth,
                        height: videoHeight
                    };
                    // Generate an audio clip from a narration prompt if provided
                    let generatedAudio = null;
                    if (audioPrompt && audioPrompt.trim() && serverUrl) {
                        try {
                            const audioRes = await fetch(`${serverUrl}/generate-audio`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt: audioPrompt })
                            });
                            if (audioRes.ok) {
                                const audioData = await audioRes.json();
                                if (audioData.audio) {
                                    generatedAudio = audioData.audio.startsWith('data:') ? audioData.audio : audioData.audio;
                                }
                            }
                        } catch (errAudio) {
                            console.warn('Audio generation failed:', errAudio);
                        }
                    }
                    // Upload user-provided audio file if present
                    let uploadedAudioFilename = null;
                    if (videoAudioFile) {
                        try {
                            uploadedAudioFilename = await uploadAudio(videoAudioFile);
                        } catch (errUploadAudio) {
                            console.warn('Audio upload failed:', errUploadAudio);
                        }
                    }
                    // Upload the image for image-to-video mode
                    if (videoMode === 'i2v') {
                        const formData = new FormData();
                        formData.append('image', i2vImage);
                        const uploadRes = await fetch(`${serverUrl}/upload/image`, {
                            method: 'POST',
                            body: formData
                        });
                        if (!uploadRes.ok) throw new Error('Image upload failed');
                        const uploadData = await uploadRes.json();
                        const filename = uploadData.subfolder ? `${uploadData.subfolder}/${uploadData.name}` : uploadData.name;
                        payload.image = filename;
                    }
                    // Add editing parameters
                    payload.trim_start = videoTrimStart;
                    payload.trim_end = videoTrimEnd;
                    if (generatedAudio) payload.narration = generatedAudio;
                    if (uploadedAudioFilename) payload.audio = uploadedAudioFilename;
                    // Send request to backend to generate the video
                    const res = await fetch(`${serverUrl}/generate-video`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!res.ok) throw new Error(`Video generation failed: ${res.status}`);
                    const data = await res.json();
                    if (data.video) {
                        const videoUrl = data.video.startsWith('data:') ? data.video : `data:video/mp4;base64,${data.video}`;
                        const metadata = { ...payload };
                        if (generatedAudio) metadata.narration = generatedAudio;
                        if (uploadedAudioFilename) metadata.audio = uploadedAudioFilename;
                        // Prepend new video to the gallery and video results
                        setGeneratedImages(prev => [
                            { url: videoUrl, metadata, isVideo: true },
                            ...prev
                        ]);
                        setVideoResults(prev => [
                            { url: videoUrl, metadata },
                            ...prev
                        ]);
                    }
                    setVideoGenerating(false);
                } catch (err) {
                    console.error(err);
                    setVideoError(err.message || 'Video generation failed');
                    setVideoGenerating(false);
                }
            };

            // Wrap image generation to add the task to the queue and record its status.
            // Concurrency-aware wrapper for image generation.  Adds tasks to the queue and
            // schedules execution when GPU/CPU resources are available.
            const generateImageWithQueue = async () => {
                const id = Date.now() + Math.random();
                const taskPrompt = prompt;
                // Add new task as queued
                setGenerationQueue(prev => [...prev, { id, type: 'image', prompt: taskPrompt, status: 'queued' }]);
                const runTask = async () => {
                    setActiveTasks(cnt => cnt + 1);
                    // Mark task as processing
                    setGenerationQueue(prev => prev.map(t => t.id === id ? { ...t, status: 'processing' } : t));
                    try {
                        await generateImage();
                        setGenerationQueue(prev => prev.map(t => t.id === id ? { ...t, status: 'done' } : t));
                    } catch (err) {
                        setGenerationQueue(prev => prev.map(t => t.id === id ? { ...t, status: 'error', error: err.message } : t));
                    } finally {
                        setActiveTasks(cnt => cnt - 1);
                    }
                };
                const check = () => {
                    if (activeTasks < maxConcurrency) {
                        runTask();
                    } else {
                        // Retry in a short interval if concurrency is saturated
                        setTimeout(check, 500);
                    }
                };
                check();
            };

            // Concurrency-aware wrapper for video generation.  Supports both text-to-video and image-to-video tasks.
            const generateVideoWithQueue = async () => {
                const id = Date.now() + Math.random();
                const taskPrompt = videoMode === 't2v' ? (prompt || '') : '(image)';
                setGenerationQueue(prev => [...prev, { id, type: 'video', prompt: taskPrompt, status: 'queued' }]);
                const runTask = async () => {
                    setActiveTasks(cnt => cnt + 1);
                    setGenerationQueue(prev => prev.map(t => t.id === id ? { ...t, status: 'processing' } : t));
                    try {
                        await generateVideo();
                        setGenerationQueue(prev => prev.map(t => t.id === id ? { ...t, status: 'done' } : t));
                    } catch (err) {
                        setGenerationQueue(prev => prev.map(t => t.id === id ? { ...t, status: 'error', error: err.message } : t));
                    } finally {
                        setActiveTasks(cnt => cnt - 1);
                    }
                };
                const check = () => {
                    if (activeTasks < maxConcurrency) {
                        runTask();
                    } else {
                        setTimeout(check, 500);
                    }
                };
                check();
            };

            // Export helpers: save data structures as JSON files for sharing.
            const exportDataToFile = (dataString, filename) => {
                const blob = new Blob([dataString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            };

            const exportPresets = () => {
                const data = JSON.stringify(presets, null, 2);
                exportDataToFile(data, 'presets.json');
            };

            const exportQueue = () => {
                const data = JSON.stringify(generationQueue, null, 2);
                exportDataToFile(data, 'generation_queue.json');
            };

            // Save current workflow settings (prompt, model, sampler, scheduler, loras, etc.) as a preset.
            const saveWorkflowPreset = () => {
                const name = window.prompt('Enter a name for the workflow preset:');
                if (!name) return;
                const preset = {
                    id: Date.now() + Math.random(),
                    name,
                    prompt,
                    negativePrompt,
                    model: selectedModel,
                    ggufModel: selectedGgufModel,
                    sampler: selectedSampler,
                    scheduler: selectedScheduler,
                    vae: selectedVae,
                    loras: selectedLoras,
                    faceSwapEnabled,
                    faceRestoreEnabled,
                    img2imgEnabled,
                    videoMode,
                    videoWidth,
                    videoHeight,
                    style: stylePack,
                    maxConcurrency,
                    // Additional flags can be added here as new features are introduced
                };
                setWorkflowPresets(prev => [...prev, preset]);
            };

            // Apply a workflow preset: update application state based on saved settings.
            const applyWorkflowPreset = (preset) => {
                if (!preset) return;
                setPrompt(preset.prompt || '');
                setNegativePrompt(preset.negativePrompt || '');
                if (preset.model) setSelectedModel(preset.model);
                if (preset.ggufModel) setSelectedGgufModel(preset.ggufModel);
                if (preset.sampler) setSelectedSampler(preset.sampler);
                if (preset.scheduler) setSelectedScheduler(preset.scheduler);
                if (preset.vae) setSelectedVae(preset.vae);
                if (preset.loras) setSelectedLoras(preset.loras);
                if (typeof preset.faceSwapEnabled === 'boolean') setFaceSwapEnabled(preset.faceSwapEnabled);
                if (typeof preset.faceRestoreEnabled === 'boolean') setFaceRestoreEnabled(preset.faceRestoreEnabled);
                if (typeof preset.img2imgEnabled === 'boolean') setImg2imgEnabled(preset.img2imgEnabled);
                if (preset.videoMode) setVideoMode(preset.videoMode);
                if (preset.videoWidth) setVideoWidth(preset.videoWidth);
                if (preset.videoHeight) setVideoHeight(preset.videoHeight);
                if (preset.style) setStylePack(preset.style);
                if (preset.maxConcurrency) setMaxConcurrency(preset.maxConcurrency);
            };

            // Delete a workflow preset by id
            const deleteWorkflowPreset = (id) => {
                setWorkflowPresets(prev => prev.filter(p => p.id !== id));
            };

            // Return a short description of the model by inspecting its filename.  This
            // helper is used in the Models tab to display quantisation or format.
            const getModelInfo = (modelName) => {
                if (!modelName) return '';
                const lower = modelName.toLowerCase();
                if (lower.endsWith('.gguf')) return 'GGUF';
                if (lower.includes('fp8')) return 'FP8';
                if (lower.includes('nf4')) return 'NF4';
                if (lower.includes('fp16')) return 'FP16';
                return '';
            };

            const savePreset = () => {
                const name = prompt('Preset name?');
                if (!name) return;

                const preset = {
                    name,
                    prompt,
                    negativePrompt,
                    width,
                    height,
                    steps,
                    cfgScale,
                    seed,
                    selectedModel,
                    selectedVae,
                    selectedSampler,
                    selectedScheduler,
                    selectedLoras,
                    upscaleEnabled,
                    upscaleFactor,
                    upscaleModel,
                    faceSwapEnabled
                };

                setPresets(prev => [preset, ...prev]);
            };

            const loadPreset = (preset) => {
                setPrompt(preset.prompt || '');
                setNegativePrompt(preset.negativePrompt || '');
                setWidth(preset.width || 512);
                setHeight(preset.height || 512);
                setSteps(preset.steps || 20);
                setCfgScale(preset.cfgScale || 7);
                setSeed(preset.seed ?? -1);
                setSelectedModel(preset.selectedModel || '');
                setSelectedVae(preset.selectedVae || '');
                setSelectedSampler(preset.selectedSampler || '');
                setSelectedScheduler(preset.selectedScheduler || '');
                setSelectedLoras(preset.selectedLoras || []);
                setUpscaleEnabled(!!preset.upscaleEnabled);
                setUpscaleFactor(preset.upscaleFactor || 2);
                setUpscaleModel(preset.upscaleModel || '');
                setFaceSwapEnabled(!!preset.faceSwapEnabled);
            };

            const clearAll = () => {
                if (!confirm('Clear all generated images?')) return;
                setGeneratedImages([]);
            };

            // --- Generation Logic ---
            const uploadFaceImage = async (base64Image) => {
                try {
                    const byteCharacters = atob(base64Image);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], { type: 'image/png' });

                    const formData = new FormData();
                    formData.append('image', blob, 'face_source.png');

                    const response = await fetch(`${serverUrl}/upload/image`, {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    const imagePath = result.subfolder ? `${result.subfolder}/${result.name}` : result.name;
                    return imagePath;
                } catch (error) {
                    console.error('Face image upload failed:', error);
                    throw new Error(`Failed to upload face image: ${error.message}`);
                }
            };

            const buildWorkflow = async (faceImageFilename, img2imgImageFilename, inpaintImageFilename, inpaintMaskFilename) => {
                let nodeId = 1;
                const workflow = {};

                const ckptToUse = selectedGgufModel || selectedModel;
                workflow[String(nodeId)] = {
                    class_type: 'CheckpointLoaderSimple',
                    inputs: { ckpt_name: ckptToUse }
                };
                const checkpointNode = String(nodeId++);

                let vaeNode = checkpointNode;
                if (selectedVae) {
                    workflow[String(nodeId)] = {
                        class_type: 'VAELoader',
                        inputs: { vae_name: selectedVae }
                    };
                    vaeNode = String(nodeId++);
                }

                workflow[String(nodeId)] = {
                    class_type: 'CLIPTextEncode',
                    inputs: {
                        text: prompt,
                        clip: [checkpointNode, 1]
                    }
                };
                const positiveNode = String(nodeId++);

                workflow[String(nodeId)] = {
                    class_type: 'CLIPTextEncode',
                    inputs: {
                        text: negativePrompt,
                        clip: [checkpointNode, 1]
                    }
                };
                const negativeNode = String(nodeId++);

                let currentModel = checkpointNode;
                let currentClip = checkpointNode;
                for (const lora of selectedLoras) {
                    workflow[String(nodeId)] = {
                        class_type: 'LoraLoader',
                        inputs: {
                            lora_name: lora.name,
                            strength_model: lora.strength,
                            strength_clip: lora.strength,
                            model: [currentModel, 0],
                            clip: [currentClip, 1]
                        }
                    };
                    currentModel = String(nodeId);
                    currentClip = String(nodeId);
                    nodeId++;
                }

                // Conditional Latent Generation
                let latentNode;

                if (inpaintEnabled && inpaintImageFilename && inpaintMaskFilename) {
                    // INPAINTING MODE
                    workflow[String(nodeId)] = {
                        class_type: 'LoadImage',
                        inputs: { image: inpaintImageFilename }
                    };
                    const loadedImageNode = String(nodeId++);

                    workflow[String(nodeId)] = {
                        class_type: 'LoadImageMask',
                        inputs: {
                            image: inpaintMaskFilename,
                            channel: 'red'
                        }
                    };
                    const maskNode = String(nodeId++);

                    workflow[String(nodeId)] = {
                        class_type: 'VAEEncodeForInpaint',
                        inputs: {
                            pixels: [loadedImageNode, 0],
                            vae: [vaeNode, selectedVae ? 0 : 2],
                            mask: [maskNode, 0],
                            grow_mask_by: 6
                        }
                    };
                    latentNode = String(nodeId++);

                } else if (img2imgEnabled && img2imgImageFilename) {
                    // IMG2IMG MODE
                    workflow[String(nodeId)] = {
                        class_type: 'LoadImage',
                        inputs: { image: img2imgImageFilename }
                    };
                    const loadedImageNode = String(nodeId++);

                    workflow[String(nodeId)] = {
                        class_type: 'VAEEncode',
                        inputs: {
                            pixels: [loadedImageNode, 0],
                            vae: [vaeNode, selectedVae ? 0 : 2]
                        }
                    };
                    latentNode = String(nodeId++);

                } else {
                    // NORMAL TEXT2IMG MODE
                    workflow[String(nodeId)] = {
                        class_type: 'EmptyLatentImage',
                        inputs: {
                            width: width,
                            height: height,
                            batch_size: batchSizeValue
                        }
                    };
                    latentNode = String(nodeId++);
                }

                workflow[String(nodeId)] = {
                    class_type: 'KSampler',
                    inputs: {
                        seed: seed === -1 ? Math.floor(Math.random() * 1000000000) : seed,
                        steps: steps,
                        cfg: cfgScale,
                        sampler_name: selectedSampler,
                        scheduler: selectedScheduler,
                        denoise: (inpaintEnabled ? inpaintStrength : (img2imgEnabled ? img2imgStrength : 1.0)),
                        model: [currentModel, 0],
                        positive: [positiveNode, 0],
                        negative: [negativeNode, 0],
                        latent_image: [latentNode, 0]
                    }
                };
                const samplerNode = String(nodeId++);

                workflow[String(nodeId)] = {
                    class_type: 'VAEDecode',
                    inputs: {
                        samples: [samplerNode, 0],
                        vae: [vaeNode, selectedVae ? 0 : 2]
                    }
                };
                let currentImageNode = String(nodeId++);

                if (faceSwapEnabled && faceImageFilename) {
                    workflow[String(nodeId)] = {
                        class_type: 'LoadImage',
                        inputs: {
                            image: faceImageFilename
                        }
                    };
                    const sourceFaceNode = String(nodeId++);

                    workflow[String(nodeId)] = {
                        class_type: 'FacelessFaceSwap',
                        inputs: {
                            target_images: [currentImageNode, 0],
                            source_image: [sourceFaceNode, 0],
                            face_swapper_model: 'inswapper_128.onnx',
                            face_detector_model: 'yoloface_8n.onnx',
                            face_recognizer_model: 'arcface_w600k_r50.onnx'
                        }
                    };
                    currentImageNode = String(nodeId++);

                    if (faceRestoreEnabled) {
                        workflow[String(nodeId)] = {
                            class_type: 'FacelessFaceRestore',
                            inputs: {
                                images: [currentImageNode, 0]
                            }
                        };
                        currentImageNode = String(nodeId++);
                    }
                }

                if (upscaleEnabled && upscaleModel) {
                    workflow[String(nodeId)] = {
                        class_type: 'UpscaleModelLoader',
                        inputs: { model_name: upscaleModel }
                    };
                    const upscaleModelNode = String(nodeId++);

                    workflow[String(nodeId)] = {
                        class_type: 'ImageUpscaleWithModel',
                        inputs: {
                            upscale_model: [upscaleModelNode, 0],
                            image: [currentImageNode, 0]
                        }
                    };
                    currentImageNode = String(nodeId++);
                }

                workflow[String(nodeId)] = {
                    class_type: 'SaveImage',
                    inputs: {
                        filename_prefix: 'AI_Studio_Pro',
                        images: [currentImageNode, 0]
                    }
                };

                return workflow;
            };

            const waitForCompletion = async (promptId) => {
                let attempts = 0;
                const maxAttempts = 300;

                while (attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    try {
                        const response = await fetch(`${serverUrl}/history/${promptId}`);
                        const history = await response.json();

                        if (history[promptId]?.outputs) {
                            const outputs = history[promptId].outputs;

                            for (const nodeId in outputs) {
                                if (outputs[nodeId].images) {
                                    for (const image of outputs[nodeId].images) {
                                        const imageUrl = `${serverUrl}/view?filename=${image.filename}&subfolder=${image.subfolder || ''}&type=${image.type || 'output'}`;
                                        const metadata = {
                                            prompt,
                                            negativePrompt,
                                            width,
                                            height,
                                            steps,
                                            cfgScale,
                                            seed,
                                            selectedModel,
                                            selectedVae,
                                            selectedSampler,
                                            selectedScheduler,
                                            selectedLoras,
                                            faceSwapEnabled,
                                            faceRestoreEnabled,
                                            upscaleEnabled,
                                            timestamp: new Date().toISOString(),
                                            // Include watermark code if enabled for AWB persona
                                            watermark: watermarkEnabled && selectedPersona === 'awb' ? 'AWB-LGL-LOCK' : null,
                                            persona: selectedPersona || 'default'
                                        };

                                        setGeneratedImages(prev => [{ url: imageUrl, metadata }, ...prev]);
                                        setLatestImage(imageUrl);
                                    }
                                }
                            }

                            setGenerating(false);
                            setProgress(100);
                            setProgressText('Complete!');

                            setTimeout(() => {
                                setProgress(0);
                                setProgressText('');
                            }, 1500);

                            return;
                        }
                    } catch (error) {
                        console.error('Error checking completion:', error);
                    }

                    attempts++;
                    setProgress(Math.min((attempts / maxAttempts) * 100, 95));
                }

                throw new Error('Generation timeout after 5 minutes');
            };

            const generateImage = async () => {
                if (!connected) {
                    setErrorMessage('Not Connected');
                    setErrorDetails('Please connect to ComfyUI server first');
                    return;
                }
                if (!prompt.trim()) {
                    setErrorMessage('No Prompt');
                    setErrorDetails('Please enter a prompt');
                    return;
                }
                if (faceSwapEnabled && !faceSwapImage) {
                    setErrorMessage('No Face Image');
                    setErrorDetails('Please upload a source face image');
                    return;
                }
                if (faceSwapEnabled && !facelessDetected) {
                    setErrorMessage('Faceless Not Detected');
                    setErrorDetails('Faceless nodes not found on ComfyUI server');
                    return;
                }

                try {
                    setGenerating(true);
                    setProgress(0);
                    setProgressText('Starting...');
                    setErrorMessage('');
                    setErrorDetails('');

                    // Record this prompt in the prompt library so it can be reused later.
                    addCurrentPromptToLibrary();

                    // Prepare filenames outside of conditional blocks so they remain in scope.  Each
                    // feature (face swap, img2img, inpainting) operates independently.
                    let faceImageFilename = null;
                    let img2imgImageFilename = null;
                    let inpaintImageFilename = null;
                    let inpaintMaskFilename = null;

                    // Upload face image if face swapping is enabled
                    if (faceSwapEnabled && faceSwapImage) {
                        setProgressText('Uploading face image...');
                        faceImageFilename = await uploadFaceImage(faceSwapImage);
                    }
                    // Upload image for img2img if enabled
                    if (img2imgEnabled && img2imgImage) {
                        setProgressText('Uploading source image...');
                        img2imgImageFilename = await uploadImg2ImgImage(img2imgImage);
                    }
                    // Upload image and mask for inpainting if enabled
                    if (inpaintEnabled && inpaintImage) {
                        setProgressText('Uploading image and mask...');
                        inpaintImageFilename = await uploadImg2ImgImage(inpaintImage);
                        const maskFile = await getMaskAsImage();
                        inpaintMaskFilename = await uploadInpaintMask(maskFile);
                    }

                    setProgressText('Building workflow...');
                    const workflow = await buildWorkflow(faceImageFilename, img2imgImageFilename, inpaintImageFilename, inpaintMaskFilename);
                    console.log('Generated workflow:', JSON.stringify(workflow, null, 2));

                    setProgressText('Sending to ComfyUI...');
                    const response = await fetch(`${serverUrl}/prompt`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: workflow })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('ComfyUI Error:', errorData);
                        throw new Error(JSON.stringify(errorData, null, 2));
                    }

                    const result = await response.json();
                    if (result.error) {
                        throw new Error(JSON.stringify(result.error, null, 2));
                    }

                    setProgressText('Generating...');
                    await waitForCompletion(result.prompt_id);

                } catch (error) {
                    setErrorMessage('Generation Failed');
                    setErrorDetails(error.message);
                    setGenerating(false);
                    setProgress(0);
                    setProgressText('');
                    console.error('Full error:', error);
                }
            };

            const startGeneration = generateImage;

            // GGUF Generation Function
            const generateGgufImage = async () => {
                if (!connected) {
                    setErrorMessage('Not Connected');
                    setErrorDetails('Please connect to ComfyUI server first');
                    return;
                }
                if (!ggufPrompt.trim()) {
                    setErrorMessage('No Prompt');
                    setErrorDetails('Please enter a prompt');
                    return;
                }
                if (!selectedGgufModel) {
                    setErrorMessage('No GGUF Model');
                    setErrorDetails('Please select a GGUF model');
                    return;
                }
                if (faceSwapEnabled && !faceSwapImage) {
                    setErrorMessage('No Face Image');
                    setErrorDetails('Please upload a source face image');
                    return;
                }
                if (faceSwapEnabled && !facelessDetected) {
                    setErrorMessage('Faceless Not Detected');
                    setErrorDetails('Faceless nodes not found on ComfyUI server');
                    return;
                }

                try {
                    setGgufGenerating(true);
                    setProgress(0);
                    setProgressText('Starting GGUF generation...');
                    setErrorMessage('');
                    setErrorDetails('');

                    // Prepare filenames for uploaded images
                    let faceImageFilename = null;
                    let img2imgImageFilename = null;

                    // Upload face image if face swapping is enabled
                    if (faceSwapEnabled && faceSwapImage) {
                        setProgressText('Uploading face image...');
                        faceImageFilename = await uploadFaceImage(faceSwapImage);
                    }

                    // Upload image for img2img if enabled
                    if (img2imgEnabled && img2imgImage) {
                        setProgressText('Uploading source image...');
                        img2imgImageFilename = await uploadImg2ImgImage(img2imgImage);
                    }

                    setProgressText('Building GGUF workflow...');
                    // Build GGUF workflow with uploaded image filenames
                    const workflow = buildGgufWorkflow(faceImageFilename, img2imgImageFilename);
                    console.log('Generated GGUF workflow:', JSON.stringify(workflow, null, 2));

                    setProgressText('Sending to ComfyUI...');
                    const response = await fetch(`${serverUrl}/prompt`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: workflow })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('ComfyUI Error:', errorData);
                        throw new Error(JSON.stringify(errorData, null, 2));
                    }

                    const result = await response.json();
                    if (result.error) {
                        throw new Error(JSON.stringify(result.error, null, 2));
                    }

                    setProgressText('Generating...');
                    await waitForCompletion(result.prompt_id);

                } catch (error) {
                    setErrorMessage('GGUF Generation Failed');
                    setErrorDetails(error.message);
                    setGgufGenerating(false);
                    setProgress(0);
                    setProgressText('');
                    console.error('Full error:', error);
                }
            };

            // Build GGUF workflow based on screenshot structure
            const buildGgufWorkflow = (faceImageFilename = null, img2imgImageFilename = null) => {
                console.log('=== Building GGUF Workflow ===');
                console.log('Face swap enabled:', faceSwapEnabled, 'Filename:', faceImageFilename);
                console.log('Img2Img enabled:', img2imgEnabled, 'Filename:', img2imgImageFilename);
                console.log('Upscale enabled:', upscaleEnabled);

                let nodeId = 1;
                const workflow = {};

                // Node 1: GGUF Loader
                console.log(`Creating node ${nodeId}: GGUF/UNET Loader`);
                workflow[nodeId++] = {
                    "inputs": {
                        "unet_name": selectedGgufModel
                    },
                    "class_type": "UNETLoader",
                    "_meta": { "title": "GGUF Loader" }
                };

                // Node 2: GGUF CLIP Loader
                const clipNode = nodeId++;
                console.log(`Creating node ${clipNode}: CLIP Loader`);
                workflow[clipNode] = {
                    "inputs": {
                        "clip_name": selectedGgufClipModel || availableGgufClipModels[0] || selectedGgufModel,
                        "type": selectedGgufClipType
                    },
                    "class_type": "CLIPLoader",
                    "_meta": { "title": "GGUF CLIP Loader" }
                };

                // Node 3: GGUF VAE Loader
                const vaeNode = nodeId++;
                console.log(`Creating node ${vaeNode}: VAE Loader`);
                workflow[vaeNode] = {
                    "inputs": {
                        "vae_name": selectedGgufVae || availableVaes[0] || "ae.safetensors"
                    },
                    "class_type": "VAELoader",
                    "_meta": { "title": "GGUF VAE Loader" }
                };

                let currentModel = [1, 0];
                let currentClip = [clipNode, 0];

                // Add LoRAs
                if (ggufSelectedLoras && ggufSelectedLoras.length > 0) {
                    console.log(`Adding ${ggufSelectedLoras.length} LoRAs`);
                    ggufSelectedLoras.forEach((lora, index) => {
                        const loraNode = nodeId++;
                        console.log(`Creating node ${loraNode}: LoRA ${index + 1} - ${lora.name}`);
                        workflow[loraNode] = {
                            "inputs": {
                                "lora_name": lora.name,
                                "strength_model": lora.strength,
                                "strength_clip": lora.strength,
                                "model": currentModel,
                                "clip": currentClip
                            },
                            "class_type": "LoraLoader",
                            "_meta": { "title": `Load LoRA ${index + 1}` }
                        };
                        currentModel = [loraNode, 0];
                        currentClip = [loraNode, 1];
                    });
                }

                // Node: CLIP Text Encode (Positive)
                const positiveNode = nodeId++;
                console.log(`Creating node ${positiveNode}: CLIP Text Encode (Positive)`);
                workflow[positiveNode] = {
                    "inputs": {
                        "text": ggufPrompt,
                        "clip": currentClip
                    },
                    "class_type": "CLIPTextEncode",
                    "_meta": { "title": "CLIP Text Encode (Prompt)" }
                };

                // Node: CLIP Text Encode (Negative)
                const negativeNode = nodeId++;
                console.log(`Creating node ${negativeNode}: CLIP Text Encode (Negative)`);
                workflow[negativeNode] = {
                    "inputs": {
                        "text": ggufNegativePrompt,
                        "clip": currentClip
                    },
                    "class_type": "CLIPTextEncode",
                    "_meta": { "title": "CLIP Text Encode (Negative)" }
                };

                // Handle Img2Img if enabled
                let latentSource;
                if (img2imgEnabled && img2imgImageFilename) {
                    console.log('Adding Img2Img nodes');
                    // Load image for img2img
                    const loadImgNode = nodeId++;
                    console.log(`Creating node ${loadImgNode}: Load Image (Img2Img)`);
                    workflow[loadImgNode] = {
                        "inputs": {
                            "image": img2imgImageFilename
                        },
                        "class_type": "LoadImage",
                        "_meta": { "title": "Load Image (Img2Img)" }
                    };

                    // VAE Encode
                    const vaeEncodeNode = nodeId++;
                    console.log(`Creating node ${vaeEncodeNode}: VAE Encode`);
                    workflow[vaeEncodeNode] = {
                        "inputs": {
                            "pixels": [loadImgNode, 0],
                            "vae": [vaeNode, 0]
                        },
                        "class_type": "VAEEncode",
                        "_meta": { "title": "VAE Encode" }
                    };

                    latentSource = [vaeEncodeNode, 0];
                } else {
                    console.log('Using Empty Latent Image');
                    // Node: Empty Latent Image (MUST be before KSampler)
                    const emptyLatentNode = nodeId++;
                    console.log(`Creating node ${emptyLatentNode}: Empty Latent Image`);
                    workflow[emptyLatentNode] = {
                        "inputs": {
                            "width": ggufWidth,
                            "height": ggufHeight,
                            "batch_size": ggufBatchSize
                        },
                        "class_type": "EmptyLatentImage",
                        "_meta": { "title": "Empty Latent Image" }
                    };

                    latentSource = [emptyLatentNode, 0];
                }

                // Node: KSampler
                const samplerNode = nodeId++;
                console.log(`Creating node ${samplerNode}: KSampler`);
                workflow[samplerNode] = {
                    "inputs": {
                        "seed": ggufSeed,
                        "steps": ggufSteps,
                        "cfg": ggufCfgScale,
                        "sampler_name": selectedGgufSampler || selectedSampler || "dpmpp_sde",
                        "scheduler": selectedGgufScheduler || selectedScheduler || "karras",
                        "denoise": img2imgEnabled ? img2imgStrength : ggufDenoise,
                        "model": currentModel,
                        "positive": [positiveNode, 0],
                        "negative": [negativeNode, 0],
                        "latent_image": latentSource
                    },
                    "class_type": "KSampler",
                    "_meta": { "title": "KSampler" }
                };

                // Node: VAE Decode
                const vaeDecodeNode = nodeId++;
                console.log(`Creating node ${vaeDecodeNode}: VAE Decode`);
                workflow[vaeDecodeNode] = {
                    "inputs": {
                        "samples": [samplerNode, 0],
                        "vae": [vaeNode, 0]
                    },
                    "class_type": "VAEDecode",
                    "_meta": { "title": "VAE Decode" }
                };

                let currentImage = [vaeDecodeNode, 0];

                // Add Face Swap if enabled
                if (faceSwapEnabled && faceImageFilename && facelessDetected) {
                    console.log('Adding Face Swap nodes');
                    const faceLoadNode = nodeId++;
                    console.log(`Creating node ${faceLoadNode}: Load Face Image`);
                    workflow[faceLoadNode] = {
                        "inputs": {
                            "image": faceImageFilename
                        },
                        "class_type": "LoadImage",
                        "_meta": { "title": "Load Face Image" }
                    };

                    const faceSwapNode = nodeId++;
                    console.log(`Creating node ${faceSwapNode}: Faceless Face Swap`);
                    workflow[faceSwapNode] = {
                        "inputs": {
                            "input_image": currentImage,
                            "source_image": [faceLoadNode, 0],
                            "facedetection": "retinaface_resnet50"
                        },
                        "class_type": "FacelessFaceSwap",
                        "_meta": { "title": "Faceless Face Swap" }
                    };

                    currentImage = [faceSwapNode, 0];
                }

                // Add Upscale if enabled
                if (upscaleEnabled) {
                    console.log('Adding Upscale nodes');
                    const upscaleLoaderNode = nodeId++;
                    console.log(`Creating node ${upscaleLoaderNode}: Load Upscale Model`);
                    workflow[upscaleLoaderNode] = {
                        "inputs": {
                            "model_name": upscaleModel || availableUpscalers[0]
                        },
                        "class_type": "UpscaleModelLoader",
                        "_meta": { "title": "Load Upscale Model" }
                    };

                    const upscaleNode = nodeId++;
                    console.log(`Creating node ${upscaleNode}: Upscale Image`);
                    workflow[upscaleNode] = {
                        "inputs": {
                            "upscale_model": [upscaleLoaderNode, 0],
                            "image": currentImage
                        },
                        "class_type": "ImageUpscaleWithModel",
                        "_meta": { "title": "Upscale Image" }
                    };

                    currentImage = [upscaleNode, 0];
                }

                // Node: Invisible Watermark Encode (if watermark text is provided)
                // NOTE: Watermark functionality disabled - PhotoMakerEncode is wrong class_type
                // Enable this when you have the correct watermark node installed in ComfyUI
                /* 
                if (ggufWatermarkText && ggufWatermarkText.trim() !== '') {
                    console.log('Adding Watermark node');
                    const watermarkNode = nodeId++;
                    console.log(`Creating node ${watermarkNode}: Watermark Encode`);
                    workflow[watermarkNode] = {
                        "inputs": {
                            "watermark_text": ggufWatermarkText,
                            "image": currentImage
                        },
                        "class_type": "PhotoMakerEncode",  // WRONG! PhotoMaker is for character consistency
                        "_meta": { "title": "Invisible Watermark Encode" }
                    };
 
                    currentImage = [watermarkNode, 0];
                }
                */
                console.log('Watermark node skipped (disabled until correct class_type configured)');

                // Node: Save Image
                const saveNode = nodeId++;
                console.log(`Creating node ${saveNode}: Save Image (final node)`);
                workflow[saveNode] = {
                    "inputs": {
                        "filename_prefix": "AWDigitalworld_AI_Hub_GGUF",
                        "images": currentImage
                    },
                    "class_type": "SaveImage",
                    "_meta": { "title": "Save Image" }
                };

                console.log('=== GGUF Workflow Complete ===');
                console.log('Total nodes created:', Object.keys(workflow).length);
                console.log('Node IDs:', Object.keys(workflow).join(', '));

                // Validate workflow structure
                const nodeIds = Object.keys(workflow).map(Number).sort((a, b) => a - b);
                console.log('Sorted node IDs:', nodeIds);

                // Check for gaps in node IDs
                for (let i = 0; i < nodeIds.length - 1; i++) {
                    if (nodeIds[i + 1] - nodeIds[i] > 1) {
                        console.warn(`Warning: Gap in node IDs between ${nodeIds[i]} and ${nodeIds[i + 1]}`);
                    }
                }

                // Validate all node references
                Object.entries(workflow).forEach(([id, node]) => {
                    Object.entries(node.inputs || {}).forEach(([inputName, inputValue]) => {
                        if (Array.isArray(inputValue) && typeof inputValue[0] === 'number') {
                            if (!workflow[inputValue[0]]) {
                                console.error(`ERROR: Node ${id} references missing node ${inputValue[0]} in input "${inputName}"`);
                            }
                        }
                    });
                });

                return workflow;
            };

            const copyPromptToClipboard = (text) => {
                navigator.clipboard.writeText(text || '');
            };

            // Filter prompt library based on search query and tag selection
            const filteredPrompts = promptLibrary.filter(item => {
                const q = searchQuery.toLowerCase();
                const matchQuery = !q || (item.prompt && item.prompt.toLowerCase().includes(q)) || (item.negativePrompt && item.negativePrompt.toLowerCase().includes(q));
                const matchTag = selectedTag ? ((item.tags || []).includes(selectedTag)) : true;
                return matchQuery && matchTag;
            });

            // Pagination calculations for gallery
            const totalGalleryPages = Math.max(Math.ceil(generatedImages.length / imagesPerPage), 1);
            const startGalleryIndex = (galleryPage - 1) * imagesPerPage;
            const displayedImages = generatedImages.slice(startGalleryIndex, startGalleryIndex + imagesPerPage);
            const prevGalleryPage = () => {
                if (galleryPage > 1) setGalleryPage(galleryPage - 1);
            };
            const nextGalleryPage = () => {
                if (galleryPage < totalGalleryPages) setGalleryPage(galleryPage + 1);
            };

            // Pagination calculations for prompt library cards
            const totalPromptPages = Math.max(Math.ceil(filteredPrompts.length / promptsPerPage), 1);
            const startPromptIndex = (promptPage - 1) * promptsPerPage;
            const displayedPromptCards = filteredPrompts.slice(startPromptIndex, startPromptIndex + promptsPerPage);
            const prevPromptPage = () => {
                if (promptPage > 1) setPromptPage(promptPage - 1);
            };
            const nextPromptPage = () => {
                if (promptPage < totalPromptPages) setPromptPage(promptPage + 1);
            };

            return (
                <div className="app-container">
                    {/* Global App Header */}
                    <div className="app-header">
                        <div className="app-title">AI Studio Pro</div>
                        <div className="header-actions">
                            <span className={`status-indicator ${connected ? 'status-connected' : 'status-disconnected'}`}>
                                <span style={{ width: '8px', height: '8px', borderRadius: '50%', background: 'currentColor', display: 'inline-block' }} />
                                {connected ? 'Connected' : 'Disconnected'}
                            </span>
                            <button className={`voice-button ${listening ? 'listening' : ''}`} onClick={toggleListening}>
                                {listening ? 'ðŸŽ¤ Stop' : 'ðŸŽ¤ Voice'}
                            </button>
                        </div>
                    </div>

                    {/* System Stats Bars */}
                    <div className="stats-container">
                        <div className="stat-bar">
                            <div className="stat-bar-label">
                                ðŸ–¥ï¸ CPU {stats.cpu !== null && stats.cpu >= 0 ? `${stats.cpu}%` : 'N/A'}
                            </div>
                            <div className="stat-bar-track">
                                <div
                                    className="stat-bar-fill"
                                    style={{
                                        width: `${(stats.cpu !== null && stats.cpu >= 0 ? stats.cpu : 0)}%`,
                                        background: stats.cpu > 90 ? '#ef4444' : stats.cpu > 70 ? '#f59e0b' : '#10b981'
                                    }}
                                />
                            </div>
                        </div>
                        <div className="stat-bar">
                            <div className="stat-bar-label">
                                ðŸ’¾ RAM {stats.ram !== null && stats.ram >= 0 ? `${stats.ram}%` : 'N/A'}
                            </div>
                            <div className="stat-bar-track">
                                <div
                                    className="stat-bar-fill"
                                    style={{
                                        width: `${(stats.ram !== null && stats.ram >= 0 ? stats.ram : 0)}%`,
                                        background: stats.ram > 90 ? '#ef4444' : stats.ram > 70 ? '#f59e0b' : '#3b82f6'
                                    }}
                                />
                            </div>
                        </div>
                        <div className="stat-bar">
                            <div className="stat-bar-label">
                                ðŸŽ® GPU {stats.gpu !== null && stats.gpu >= 0 ? `${stats.gpu}%` : 'N/A'}
                            </div>
                            <div className="stat-bar-track">
                                <div
                                    className="stat-bar-fill"
                                    style={{
                                        width: `${(stats.gpu !== null && stats.gpu >= 0 ? stats.gpu : 0)}%`,
                                        background: stats.gpu > 90 ? '#ef4444' : stats.gpu > 70 ? '#f59e0b' : '#8b5cf6'
                                    }}
                                />
                            </div>
                        </div>
                        <div className="stat-bar">
                            <div className="stat-bar-label">
                                ðŸ“Š VRAM {stats.vram !== null && stats.vram >= 0 ? `${stats.vram}%` : 'N/A'}
                            </div>
                            <div className="stat-bar-track">
                                <div
                                    className="stat-bar-fill"
                                    style={{
                                        width: `${(stats.vram !== null && stats.vram >= 0 ? stats.vram : 0)}%`,
                                        background: stats.vram > 90 ? '#ef4444' : stats.vram > 70 ? '#f59e0b' : '#06b6d4'
                                    }}
                                />
                            </div>
                        </div>
                        <div className="stat-bar">
                            <div className="stat-bar-label">
                                ðŸŒ¡ï¸ Temp {stats.temp !== null && stats.temp >= 0 ? `${stats.temp}Â°C` : 'N/A'}
                            </div>
                            <div className="stat-bar-track">
                                <div
                                    className="stat-bar-fill"
                                    style={{
                                        width: `${(stats.temp !== null && stats.temp >= 0 ? Math.min(stats.temp, 100) : 0)}%`,
                                        background: stats.temp > 80 ? '#ef4444' : stats.temp > 70 ? '#f59e0b' : '#10b981'
                                    }}
                                />
                            </div>
                        </div>
                    </div>

                    {errorMessage && (
                        <div className="error-modal" onClick={() => setErrorMessage('')}>
                            <div className="error-content" onClick={(e) => e.stopPropagation()}>
                                <div className="error-title">âš ï¸ {errorMessage}</div>
                                <div className="error-details" style={{
                                    maxHeight: '400px',
                                    overflow: 'auto',
                                    whiteSpace: 'pre-wrap',
                                    wordBreak: 'break-word',
                                    fontSize: '11px',
                                    fontFamily: 'monospace'
                                }}>{errorDetails}</div>
                                <button className="btn btn-secondary w-full" onClick={() => setErrorMessage('')}>Close</button>
                            </div>
                        </div>
                    )}

                    {/* Sidebar Toggle Button */}
                    <div className="sidebar-toggle" onClick={() => setSidebarCollapsed(!sidebarCollapsed)}>
                        {sidebarCollapsed ? 'â†’' : 'â†'}
                    </div>

                    <div className={`tab-bar ${sidebarCollapsed ? 'collapsed' : ''}`}>
                        <div
                            className={`tab ${activeTab === 'generation' ? 'active' : ''}`}
                            onClick={() => setActiveTab('generation')}
                        >
                            ðŸŽ¨ Generation
                        </div>
                        <div
                            className={`tab ${activeTab === 'gguf' ? 'active' : ''}`}
                            onClick={() => setActiveTab('gguf')}
                        >
                            âš¡ GGUF
                        </div>
                        <div
                            className={`tab ${activeTab === 'gallery' ? 'active' : ''}`}
                            onClick={() => setActiveTab('gallery')}
                        >
                            ðŸ–¼ï¸ Gallery ({generatedImages.length})
                        </div>
                        <div
                            className={`tab ${activeTab === 'library' ? 'active' : ''}`}
                            onClick={() => setActiveTab('library')}
                        >
                            ðŸ“š Library ({promptLibrary.length})
                        </div>
                        <div
                            className={`tab ${activeTab === 'prompts' ? 'active' : ''}`}
                            onClick={() => setActiveTab('prompts')}
                        >
                            ðŸ“ Pro Prompts
                        </div>
                        <div
                            className={`tab ${activeTab === 'settings' ? 'active' : ''}`}
                            onClick={() => setActiveTab('settings')}
                        >
                            âš™ï¸ Settings
                        </div>

                        <div
                            className={`tab ${activeTab === 'models' ? 'active' : ''}`}
                            onClick={() => setActiveTab('models')}
                        >
                            ðŸ“¦ Models
                        </div>
                        <div
                            className={`tab ${activeTab === 'manager' ? 'active' : ''}`}
                            onClick={() => setActiveTab('manager')}
                        >
                            ðŸ§© Manager
                        </div>
                        <div
                            className={`tab ${activeTab === 'projects' ? 'active' : ''}`}
                            onClick={() => setActiveTab('projects')}
                        >
                            ðŸ—‚ï¸ Projects
                        </div>
                        <div
                            className={`tab ${activeTab === 'caption' ? 'active' : ''}`}
                            onClick={() => setActiveTab('caption')}
                        >
                            ðŸ·ï¸ Caption
                        </div>
                        <div
                            className={`tab ${activeTab === 'social' ? 'active' : ''}`}
                            onClick={() => setActiveTab('social')}
                        >
                            ðŸ“± Social
                        </div>
                        <div
                            className={`tab ${activeTab === 'marketing' ? 'active' : ''}`}
                            onClick={() => setActiveTab('marketing')}
                        >
                            ðŸ“£ Marketing
                        </div>
                    </div>

                    {/* GENERATION TAB */}
                    <div className={`tab-content ${activeTab === 'generation' ? 'active' : ''}`}>
                        <div className="generation-panel">
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸŽ¨ AI Studio Pro v2</div>
                                    <div className="panel-subtitle">ComfyUI Desktop Client with Faceless</div>
                                </div>
                            </div>

                            <div className="controls-grid">
                                {/* LEFT COLUMN: Sidebar with ALL Controls */}
                                <div className="accordion">
                                    {/* Presets */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('presets') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('presets')}
                                        >
                                            <span>ðŸ“ Presets & History</span>
                                            <span className={`accordion-icon ${openAccordions.includes('presets') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('presets') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <button className="btn btn-secondary btn-small" onClick={savePreset}>
                                                    ðŸ’¾ Save current settings as preset
                                                </button>
                                                <div style={{ marginTop: '8px', fontSize: '11px', color: '#9ca3af' }}>
                                                    Click a preset to load it:
                                                </div>
                                                <div style={{ marginTop: '6px' }}>
                                                    {presets.length === 0 && (
                                                        <div style={{ fontSize: '11px', color: '#6b7280' }}>
                                                            No presets yet.
                                                        </div>
                                                    )}
                                                    {presets.map((p, idx) => (
                                                        <div
                                                            key={idx}
                                                            style={{
                                                                padding: '6px 8px',
                                                                borderRadius: '8px',
                                                                border: '1px solid rgba(55,65,81,0.9)',
                                                                marginBottom: '6px',
                                                                cursor: 'pointer',
                                                                fontSize: '11px'
                                                            }}
                                                            onClick={() => loadPreset(p)}
                                                        >
                                                            {p.name}
                                                        </div>
                                                    ))}
                                                </div>

                                                {/* Workflow Presets */}
                                                <div style={{ marginTop: '12px', borderTop: '1px solid rgba(55,65,81,0.6)', paddingTop: '8px' }}>
                                                    <button className="btn btn-secondary btn-small" onClick={saveWorkflowPreset}>
                                                        ðŸ’¾ Save workflow preset
                                                    </button>
                                                    <div style={{ marginTop: '8px', fontSize: '11px', color: '#9ca3af' }}>
                                                        Click a workflow preset to apply it:
                                                    </div>
                                                    {workflowPresets.length === 0 && (
                                                        <div style={{ fontSize: '11px', color: '#6b7280', marginTop: '4px' }}>
                                                            No workflow presets yet.
                                                        </div>
                                                    )}
                                                    {workflowPresets.map((wp) => (
                                                        <div
                                                            key={wp.id}
                                                            style={{
                                                                padding: '6px 8px',
                                                                borderRadius: '8px',
                                                                border: '1px solid rgba(55,65,81,0.9)',
                                                                marginBottom: '6px',
                                                                fontSize: '11px',
                                                                display: 'flex',
                                                                justifyContent: 'space-between',
                                                                alignItems: 'center'
                                                            }}
                                                        >
                                                            <span onClick={() => applyWorkflowPreset(wp)} style={{ cursor: 'pointer', flex: 1 }}>
                                                                {wp.name}
                                                            </span>
                                                            <div style={{ display: 'flex', gap: '4px' }}>
                                                                <button className="btn btn-secondary btn-small" onClick={() => applyWorkflowPreset(wp)} style={{ fontSize: '10px' }}>
                                                                    Use
                                                                </button>
                                                                <button className="btn btn-secondary btn-small" onClick={() => deleteWorkflowPreset(wp.id)} style={{ fontSize: '10px' }}>
                                                                    Delete
                                                                </button>
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Basic Settings */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('basic') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('basic')}
                                        >
                                            <span>âš™ï¸ Basic Settings</span>
                                            <span className={`accordion-icon ${openAccordions.includes('basic') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('basic') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div className="form-group">
                                                    <label className="form-label">Prompt</label>
                                                    <textarea className="form-input form-textarea"
                                                        value={prompt}
                                                        onChange={(e) => setPrompt(e.target.value)}
                                                        placeholder="Describe your image..."
                                                    />
                                                </div>
                                                <div className="form-group">
                                                    <label className="form-label">Negative Prompt</label>
                                                    <textarea className="form-input form-textarea"
                                                        value={negativePrompt}
                                                        onChange={(e) => setNegativePrompt(e.target.value)}
                                                        placeholder="Things to avoid..."
                                                    />
                                                </div>
                                                <div className="horizontal-row">
                                                    <div className="form-group">
                                                        <label className="form-label">Width</label>
                                                        <input
                                                            type="range"
                                                            className="form-range"
                                                            min="512"
                                                            max="1024"
                                                            step="64"
                                                            value={width}
                                                            onChange={(e) => setWidth(parseInt(e.target.value))}
                                                        />
                                                        <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '2px' }}>
                                                            {width}px
                                                        </div>
                                                    </div>
                                                    <div className="form-group">
                                                        <label className="form-label">Height</label>
                                                        <input
                                                            type="range"
                                                            className="form-range"
                                                            min="512"
                                                            max="1024"
                                                            step="64"
                                                            value={height}
                                                            onChange={(e) => setHeight(parseInt(e.target.value))}
                                                        />
                                                        <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '2px' }}>
                                                            {height}px
                                                        </div>
                                                    </div>
                                                </div>
                                                <div className="horizontal-row">
                                                    <div className="form-group">
                                                        <label className="form-label">Steps</label>
                                                        <input
                                                            type="range"
                                                            className="form-range"
                                                            min="10"
                                                            max="40"
                                                            step="1"
                                                            value={steps}
                                                            onChange={(e) => setSteps(parseInt(e.target.value))}
                                                        />
                                                        <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '2px' }}>
                                                            {steps}
                                                        </div>
                                                    </div>
                                                    <div className="form-group">
                                                        <label className="form-label">CFG Scale</label>
                                                        <input
                                                            type="range"
                                                            className="form-range"
                                                            min="1"
                                                            max="30"
                                                            step="0.5"
                                                            value={cfgScale}
                                                            onChange={(e) => setCfgScale(parseFloat(e.target.value))}
                                                        />
                                                        <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '2px' }}>
                                                            {cfgScale}
                                                        </div>
                                                    </div>
                                                </div>
                                                <div className="form-group">
                                                    <label className="form-label">Seed (-1 for random)</label>
                                                    <input
                                                        type="number"
                                                        className="form-input"
                                                        value={seed}
                                                        onChange={(e) => setSeed(parseInt(e.target.value))}
                                                    />
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Model Settings */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('model') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('model')}
                                        >
                                            <span>ðŸ§  Model & Sampler</span>
                                            <span className={`accordion-icon ${openAccordions.includes('model') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('model') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div className="form-group">
                                                    <label className="form-label">Checkpoint</label>
                                                    <select
                                                        className="form-select"
                                                        value={selectedModel}
                                                        onChange={(e) => setSelectedModel(e.target.value)}
                                                    >
                                                        <option value="">Select model</option>
                                                        {availableModels.map(m => (
                                                            <option key={m} value={m}>{m}</option>
                                                        ))}
                                                    </select>
                                                </div>
                                                <div className="form-group">
                                                    <label className="form-label">VAE</label>
                                                    <select
                                                        className="form-select"
                                                        value={selectedVae}
                                                        onChange={(e) => setSelectedVae(e.target.value)}
                                                    >
                                                        <option value="">Default</option>
                                                        {availableVaes.map(v => (
                                                            <option key={v} value={v}>{v}</option>
                                                        ))}
                                                    </select>
                                                </div>
                                                <div className="horizontal-row">
                                                    <div className="form-group">
                                                        <label className="form-label">Sampler</label>
                                                        <select
                                                            className="form-select"
                                                            value={selectedSampler}
                                                            onChange={(e) => setSelectedSampler(e.target.value)}
                                                        >
                                                            {availableSamplers.map(s => (
                                                                <option key={s} value={s}>{s}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                    <div className="form-group">
                                                        <label className="form-label">Scheduler</label>
                                                        <select
                                                            className="form-select"
                                                            value={selectedScheduler}
                                                            onChange={(e) => setSelectedScheduler(e.target.value)}
                                                        >
                                                            {availableSchedulers.map(s => (
                                                                <option key={s} value={s}>{s}</option>
                                                            ))}
                                                        </select>
                                                    </div>
                                                </div>
                                                {/* GGUF model selection */}
                                                <div className="form-group">
                                                    <label className="form-label">GGUF Model</label>
                                                    <select
                                                        className="form-select"
                                                        value={selectedGgufModel}
                                                        onChange={(e) => setSelectedGgufModel(e.target.value)}
                                                    >
                                                        <option value="">None</option>
                                                        {availableGgufModels.map(m => (
                                                            <option key={m} value={m}>{m}</option>
                                                        ))}
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* LoRAs */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('lora') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('lora')}
                                        >
                                            <span>ðŸŽ¨ LoRAs ({selectedLoras.length})</span>
                                            <span className={`accordion-icon ${openAccordions.includes('lora') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('lora') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div style={{ marginBottom: '8px' }}>
                                                    <button className="btn btn-secondary btn-small" onClick={addLora}>
                                                        âž• Add LoRA
                                                    </button>
                                                </div>
                                                {selectedLoras.length === 0 && (
                                                    <div style={{ fontSize: '10px', color: '#9ca3af' }}>
                                                        No LoRAs active.
                                                    </div>
                                                )}
                                                {selectedLoras.map((lora, i) => (
                                                    <div key={i} style={{
                                                        border: '1px solid rgba(55,65,81,0.9)',
                                                        borderRadius: '10px',
                                                        padding: '8px',
                                                        marginBottom: '6px'
                                                    }}>
                                                        <div style={{
                                                            display: 'flex',
                                                            justifyContent: 'space-between',
                                                            alignItems: 'center',
                                                            marginBottom: '6px'
                                                        }}>
                                                            <select
                                                                className="form-select"
                                                                value={lora.name}
                                                                onChange={(e) => updateLoraName(i, e.target.value)}
                                                            >
                                                                {availableLoras.map(name => (
                                                                    <option key={name} value={name}>{name}</option>
                                                                ))}
                                                            </select>
                                                            <button
                                                                className="btn btn-secondary btn-small"
                                                                style={{ marginLeft: '6px' }}
                                                                onClick={() => removeLora(i)}
                                                            >
                                                                âœ•
                                                            </button>
                                                        </div>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                                                            <input
                                                                type="range"
                                                                className="form-range"
                                                                min="0"
                                                                max="2"
                                                                step="0.1"
                                                                value={lora.strength}
                                                                onChange={(e) => updateLoraStrength(i, e.target.value)}
                                                            />
                                                            <input
                                                                type="number"
                                                                className="form-input"
                                                                style={{ width: '60px' }}
                                                                value={lora.strength}
                                                                onChange={(e) => updateLoraStrength(i, e.target.value)}
                                                                step="0.1"
                                                            />
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Face Swap (Moved to Left) */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('face') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('face')}
                                        >
                                            <span>ðŸ‘¤ Face Swap</span>
                                            <span className={`accordion-icon ${openAccordions.includes('face') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('face') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                {!facelessDetected && (
                                                    <div style={{
                                                        padding: '6px 8px',
                                                        background: 'rgba(127,29,29,0.2)',
                                                        border: '1px solid rgba(248,113,113,0.6)',
                                                        borderRadius: '6px',
                                                        marginBottom: '12px',
                                                        fontSize: '11px',
                                                        color: '#fecaca'
                                                    }}>
                                                        âš ï¸ Faceless nodes not detected.
                                                    </div>
                                                )}

                                                <div className="form-group">
                                                    <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                                                        <input
                                                            type="checkbox"
                                                            className="form-checkbox"
                                                            checked={faceSwapEnabled}
                                                            onChange={(e) => setFaceSwapEnabled(e.target.checked)}
                                                            disabled={!facelessDetected}
                                                        />
                                                        Enable Face Swap
                                                    </label>
                                                </div>

                                                {faceSwapEnabled && (
                                                    <>
                                                        <div className="form-group">
                                                            <label className="form-label">Source Face Image</label>
                                                            <div
                                                                className="face-upload-preview"
                                                                onClick={() => faceUploadRef.current?.click()}
                                                            >
                                                                {faceSwapImagePreview ? (
                                                                    <img src={faceSwapImagePreview} alt="Source face" />
                                                                ) : (
                                                                    <div style={{ textAlign: 'center', fontSize: '11px', color: '#9ca3af' }}>
                                                                        <div style={{ fontSize: '24px', marginBottom: '4px' }}>ðŸ‘¤</div>
                                                                        Click to upload source face
                                                                    </div>
                                                                )}
                                                            </div>
                                                            <input
                                                                ref={faceUploadRef}
                                                                type="file"
                                                                accept="image/*"
                                                                style={{ display: 'none' }}
                                                                onChange={handleFaceUpload}
                                                            />
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Upscale (Moved to Left) */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('upscale') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('upscale')}
                                        >
                                            <span>â¬†ï¸ Upscale</span>
                                            <span className={`accordion-icon ${openAccordions.includes('upscale') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('upscale') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div className="form-group">
                                                    <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                                                        <input
                                                            type="checkbox"
                                                            className="form-checkbox"
                                                            checked={upscaleEnabled}
                                                            onChange={(e) => setUpscaleEnabled(e.target.checked)}
                                                        />
                                                        Enable Upscaling
                                                    </label>
                                                </div>
                                                {upscaleEnabled && (
                                                    <>
                                                        <div className="form-group">
                                                            <label className="form-label">Upscaler Model</label>
                                                            <select
                                                                className="form-select"
                                                                value={upscaleModel}
                                                                onChange={(e) => setUpscaleModel(e.target.value)}
                                                            >
                                                                {availableUpscalers.map(u => (
                                                                    <option key={u} value={u}>{u}</option>
                                                                ))}
                                                            </select>
                                                        </div>
                                                        <div className="form-group">
                                                            <label className="form-label">Upscale Factor</label>
                                                            <select
                                                                className="form-select"
                                                                value={upscaleFactor}
                                                                onChange={(e) => setUpscaleFactor(parseInt(e.target.value))}
                                                            >
                                                                <option value={2}>2Ã—</option>
                                                                <option value={3}>3Ã—</option>
                                                                <option value={4}>4Ã—</option>
                                                            </select>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    </div>


                                    {/* ===== NEW FEATURES ===== */}

                                    {/* Video Generation */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('video') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('video')}
                                        >
                                            <span>ðŸŽ¬ Video Generation</span>
                                            <span className={`accordion-icon ${openAccordions.includes('video') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('video') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div className="form-group">
                                                    <label className="form-label">Mode</label>
                                                    <select
                                                        className="form-select"
                                                        value={videoMode}
                                                        onChange={(e) => setVideoMode(e.target.value)}
                                                    >
                                                        <option value="t2v">Text to Video</option>
                                                        <option value="i2v">Image to Video</option>
                                                    </select>
                                                </div>
                                                {videoMode === 'i2v' && (
                                                    <div className="form-group">
                                                        <label className="form-label">Source Image</label>
                                                        <div
                                                            className="face-upload-preview"
                                                            onClick={() => i2vUploadRef.current?.click()}
                                                        >
                                                            {i2vImagePreview ? (
                                                                <img src={i2vImagePreview} alt="Source" />
                                                            ) : (
                                                                <div style={{ textAlign: 'center', fontSize: '11px', color: '#9ca3af' }}>
                                                                    <div style={{ fontSize: '24px', marginBottom: '4px' }}>ðŸ–¼ï¸</div>
                                                                    Click to upload image
                                                                </div>
                                                            )}
                                                        </div>
                                                        <input
                                                            ref={i2vUploadRef}
                                                            type="file"
                                                            accept="image/*"
                                                            style={{ display: 'none' }}
                                                            onChange={handleI2vUpload}
                                                        />
                                                    </div>
                                                )}
                                                <div className="horizontal-row">
                                                    <div className="form-group">
                                                        <label className="form-label">Length (s)</label>
                                                        <input
                                                            type="number"
                                                            className="form-input"
                                                            min="1"
                                                            max="10"
                                                            value={videoLength}
                                                            onChange={(e) => setVideoLength(parseInt(e.target.value))}
                                                        />
                                                    </div>
                                                    <div className="form-group">
                                                        <label className="form-label">Frame Rate</label>
                                                        <input
                                                            type="number"
                                                            className="form-input"
                                                            min="1"
                                                            max="60"
                                                            value={frameRate}
                                                            onChange={(e) => setFrameRate(parseInt(e.target.value))}
                                                        />
                                                    </div>
                                                </div>
                                                <div className="horizontal-row">
                                                    <div className="form-group">
                                                        <label className="form-label">Width</label>
                                                        <input
                                                            type="number"
                                                            className="form-input"
                                                            min="256"
                                                            max="1920"
                                                            value={videoWidth}
                                                            onChange={(e) => setVideoWidth(parseInt(e.target.value))}
                                                        />
                                                    </div>
                                                    <div className="form-group">
                                                        <label className="form-label">Height</label>
                                                        <input
                                                            type="number"
                                                            className="form-input"
                                                            min="256"
                                                            max="1080"
                                                            value={videoHeight}
                                                            onChange={(e) => setVideoHeight(parseInt(e.target.value))}
                                                        />
                                                    </div>
                                                </div>
                                                <div className="form-group">
                                                    <label className="form-label">Narration (optional)</label>
                                                    <input
                                                        type="text"
                                                        className="form-input"
                                                        placeholder="Add spoken narration..."
                                                        value={audioPrompt}
                                                        onChange={(e) => setAudioPrompt(e.target.value)}
                                                    />
                                                </div>

                                                {/* Video Editing: Trim and Audio Upload */}
                                                <div className="horizontal-row">
                                                    <div className="form-group">
                                                        <label className="form-label">Trim Start (s)</label>
                                                        <input
                                                            type="number"
                                                            className="form-input"
                                                            min="0"
                                                            value={videoTrimStart}
                                                            onChange={(e) => setVideoTrimStart(parseFloat(e.target.value) || 0)}
                                                        />
                                                    </div>
                                                    <div className="form-group">
                                                        <label className="form-label">Trim End (s)</label>
                                                        <input
                                                            type="number"
                                                            className="form-input"
                                                            min="0"
                                                            value={videoTrimEnd}
                                                            onChange={(e) => setVideoTrimEnd(parseFloat(e.target.value) || 0)}
                                                        />
                                                    </div>
                                                </div>
                                                <div className="form-group">
                                                    <label className="form-label">Attach Audio File</label>
                                                    <input
                                                        type="file"
                                                        accept="audio/*"
                                                        className="form-input"
                                                        onChange={handleAudioUpload}
                                                    />
                                                    {videoAudioPreview && (
                                                        <audio
                                                            controls
                                                            src={videoAudioPreview}
                                                            style={{ width: '100%', marginTop: '6px', borderRadius: '8px' }}
                                                        />
                                                    )}
                                                </div>
                                                <button
                                                    className="btn btn-primary w-full"
                                                    disabled={videoGenerating}
                                                    onClick={generateVideoWithQueue}
                                                >
                                                    {videoGenerating ? 'Generating Video...' : 'ðŸŽ¬ Generate Video'}
                                                </button>
                                                {videoError && (
                                                    <div style={{ marginTop: '8px', fontSize: '11px', color: '#f87171' }}>
                                                        {videoError}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Embeddings */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('embeddings') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('embeddings')}
                                        >
                                            <span>ðŸ’Ž Embeddings ({availableEmbeddings.length})</span>
                                            <span className={`accordion-icon ${openAccordions.includes('embeddings') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('embeddings') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div style={{ marginBottom: '8px', fontSize: '11px', color: '#9ca3af' }}>
                                                    Click to insert into prompt
                                                </div>
                                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                                                    {availableEmbeddings.map((emb, idx) => (
                                                        <button
                                                            key={idx}
                                                            className="btn btn-secondary btn-small"
                                                            onClick={() => setPrompt(prev => prev + ` embedding:${emb}`)}
                                                            style={{ fontSize: '10px', padding: '4px 8px' }}
                                                        >
                                                            {emb}
                                                        </button>
                                                    ))}
                                                </div>
                                                {availableEmbeddings.length === 0 && (
                                                    <div style={{ color: '#9ca3af', fontSize: '11px', textAlign: 'center', padding: '20px' }}>
                                                        No embeddings found
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Image-to-Image */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openAccordions.includes('img2img') ? 'active' : ''}`}
                                            onClick={() => toggleAccordion('img2img')}
                                        >
                                            <span>ðŸ–¼ï¸ Image-to-Image</span>
                                            <span className={`accordion-icon ${openAccordions.includes('img2img') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openAccordions.includes('img2img') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div className="form-group">
                                                    <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                                                        <input
                                                            type="checkbox"
                                                            className="form-checkbox"
                                                            checked={img2imgEnabled}
                                                            onChange={(e) => setImg2imgEnabled(e.target.checked)}
                                                        />
                                                        Enable Image-to-Image
                                                    </label>
                                                </div>
                                                {img2imgEnabled && (
                                                    <>
                                                        <div className="form-group">
                                                            <label className="form-label">Source Image</label>
                                                            <input
                                                                type="file"
                                                                ref={img2imgUploadRef}
                                                                accept="image/*"
                                                                onChange={handleImg2ImgUpload}
                                                                style={{ display: 'none' }}
                                                            />
                                                            <button
                                                                className="btn btn-secondary btn-small"
                                                                onClick={() => img2imgUploadRef.current?.click()}
                                                            >
                                                                {img2imgImage ? 'Change Image' : 'Upload Image'}
                                                            </button>
                                                            {img2imgImagePreview && (
                                                                <div style={{ marginTop: '8px' }}>
                                                                    <img src={img2imgImagePreview} style={{ width: '100%', borderRadius: '4px' }} />
                                                                </div>
                                                            )}
                                                        </div>
                                                        <div className="form-group">
                                                            <label className="form-label">Denoising Strength</label>
                                                            <input
                                                                type="range"
                                                                className="form-range"
                                                                min="0"
                                                                max="1"
                                                                step="0.05"
                                                                value={img2imgStrength}
                                                                onChange={(e) => setImg2imgStrength(parseFloat(e.target.value))}
                                                            />
                                                            <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '2px' }}>
                                                                {img2imgStrength}
                                                            </div>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Generate Button */}
                                    <button
                                        className="btn btn-primary btn-large"
                                        onClick={generateImage}
                                        disabled={generating || !connected}
                                        style={{ width: '100%', marginTop: '8px' }}
                                    >
                                        {generating ? 'â³ Generating...' : 'ðŸŽ¨ Generate Image'}
                                    </button>
                                </div>

                                {/* RIGHT COLUMN: Preview & Generate */}
                                <div className="preview-panel">
                                    <div className="preview-header">
                                        <h3 style={{ fontSize: '14px', fontWeight: 600 }}>Preview</h3>
                                    </div>

                                    <div className="preview-content">
                                        {generating ? (
                                            <div className="progress-container">
                                                <div className="progress-bar">
                                                    <div className="progress-bar-inner" style={{ width: `${progress}%` }}></div>
                                                </div>
                                                <div className="progress-text">{progressText}</div>
                                            </div>
                                        ) : latestImage ? (
                                            <img src={latestImage} alt="Latest generation" style={{ maxWidth: '100%', borderRadius: '12px' }} />
                                        ) : (
                                            <div style={{ textAlign: 'center', color: '#6b7280', fontSize: '13px', padding: '40px' }}>
                                                Generated images will appear here
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* GGUF GENERATION TAB */}
                    <div className={`tab-content ${activeTab === 'gguf' ? 'active' : ''}`}>
                        <div className="generation-panel">
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">âš¡ GGUF Generation</div>
                                    <div className="panel-subtitle">Quantized Model Inference</div>
                                </div>
                            </div>

                            <div className="controls-grid">
                                {/* LEFT COLUMN: Controls */}
                                <div className="accordion">
                                    {/* Model Selection */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-model') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-model')}
                                        >
                                            <span>ðŸŽ¯ GGUF Model</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-model') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-model') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <label className="form-label">GGUF Model</label>
                                                <select
                                                    className="form-input"
                                                    value={selectedGgufModel}
                                                    onChange={(e) => setSelectedGgufModel(e.target.value)}
                                                >
                                                    {availableGgufModels.length > 0 ? (
                                                        availableGgufModels.map(m => <option key={m} value={m}>{m}</option>)
                                                    ) : (
                                                        <option value="">No GGUF models found - check browser console for debug info</option>
                                                    )}
                                                </select>
                                                <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '4px' }}>
                                                    GGUF models should have .gguf extension. Found: {availableGgufModels.length}
                                                </div>

                                                <label className="form-label" style={{ marginTop: '10px' }}>CLIP Type</label>
                                                <select
                                                    className="form-input"
                                                    value={selectedGgufClipType}
                                                    onChange={(e) => setSelectedGgufClipType(e.target.value)}
                                                >
                                                    <option value="stable_diffusion">Stable Diffusion</option>
                                                    <option value="stable_cascade">Stable Cascade</option>
                                                </select>

                                                <label className="form-label" style={{ marginTop: '10px' }}>CLIP Model</label>
                                                <select
                                                    className="form-input"
                                                    value={selectedGgufClipModel}
                                                    onChange={(e) => setSelectedGgufClipModel(e.target.value)}
                                                >
                                                    {availableGgufClipModels.length > 0 ? (
                                                        availableGgufClipModels.map(c => <option key={c} value={c}>{c}</option>)
                                                    ) : (
                                                        <option value="">No CLIP models found</option>
                                                    )}
                                                </select>

                                                <label className="form-label" style={{ marginTop: '10px' }}>Device</label>
                                                <select
                                                    className="form-input"
                                                    value={selectedGgufDevice}
                                                    onChange={(e) => setSelectedGgufDevice(e.target.value)}
                                                >
                                                    <option value="default">Default</option>
                                                    <option value="cpu">CPU</option>
                                                    <option value="cuda">CUDA</option>
                                                </select>

                                                <label className="form-label" style={{ marginTop: '10px' }}>VAE</label>
                                                <select
                                                    className="form-input"
                                                    value={selectedGgufVae}
                                                    onChange={(e) => setSelectedGgufVae(e.target.value)}
                                                >
                                                    {availableVaes.map(v => <option key={v} value={v}>{v}</option>)}
                                                </select>
                                            </div>
                                        </div>
                                    </div>

                                    {/* LoRAs */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-loras') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-loras')}
                                        >
                                            <span>ðŸŽ¨ LoRAs</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-loras') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-loras') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div style={{ marginBottom: '8px', fontSize: '11px', color: '#9ca3af' }}>
                                                    Available LoRAs:
                                                </div>
                                                <div style={{ maxHeight: '200px', overflowY: 'auto' }}>
                                                    {availableLoras.map(lora => {
                                                        const selected = ggufSelectedLoras.find(l => l.name === lora);
                                                        return (
                                                            <div key={lora} style={{ marginBottom: '6px' }}>
                                                                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                                    <input
                                                                        type="checkbox"
                                                                        checked={!!selected}
                                                                        onChange={() => {
                                                                            if (selected) {
                                                                                setGgufSelectedLoras(prev => prev.filter(l => l.name !== lora));
                                                                            } else {
                                                                                setGgufSelectedLoras(prev => [...prev, { name: lora, strength: 0.8 }]);
                                                                            }
                                                                        }}
                                                                    />
                                                                    <span style={{ fontSize: '11px', flex: 1 }}>{lora}</span>
                                                                    {selected && (
                                                                        <input
                                                                            type="number"
                                                                            min="0"
                                                                            max="2"
                                                                            step="0.1"
                                                                            value={selected.strength}
                                                                            onChange={(e) => {
                                                                                setGgufSelectedLoras(prev => prev.map(l =>
                                                                                    l.name === lora ? { ...l, strength: parseFloat(e.target.value) } : l
                                                                                ));
                                                                            }}
                                                                            style={{ width: '60px', fontSize: '11px' }}
                                                                            className="form-input"
                                                                        />
                                                                    )}
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Prompts */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-prompts') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-prompts')}
                                        >
                                            <span>âœï¸ Prompts</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-prompts') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-prompts') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <label className="form-label">Positive Prompt</label>
                                                <textarea className="form-input"
                                                    rows="4"
                                                    value={ggufPrompt}
                                                    onChange={(e) => setGgufPrompt(e.target.value)}
                                                    placeholder="Describe what you want to generate..."
                                                />

                                                <label className="form-label" style={{ marginTop: '10px' }}>Negative Prompt</label>
                                                <textarea className="form-input"
                                                    rows="3"
                                                    value={ggufNegativePrompt}
                                                    onChange={(e) => setGgufNegativePrompt(e.target.value)}
                                                    placeholder="What to avoid..."
                                                />
                                            </div>
                                        </div>
                                    </div>

                                    {/* Sampling Parameters */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-sampling') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-sampling')}
                                        >
                                            <span>âš™ï¸ Sampling</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-sampling') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-sampling') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <label className="form-label">Seed</label>
                                                <input
                                                    type="number"
                                                    className="form-input"
                                                    value={ggufSeed}
                                                    onChange={(e) => setGgufSeed(parseInt(e.target.value))}
                                                />

                                                <label className="form-label" style={{ marginTop: '10px' }}>Control After Generate</label>
                                                <select
                                                    className="form-input"
                                                    value={ggufControlAfterGenerate}
                                                    onChange={(e) => setGgufControlAfterGenerate(e.target.value)}
                                                >
                                                    <option value="fixed">Fixed</option>
                                                    <option value="increment">Increment</option>
                                                    <option value="decrement">Decrement</option>
                                                    <option value="randomize">Randomize</option>
                                                </select>

                                                <label className="form-label" style={{ marginTop: '10px' }}>Steps: {ggufSteps}</label>
                                                <input
                                                    type="range"
                                                    min="1"
                                                    max="150"
                                                    value={ggufSteps}
                                                    onChange={(e) => setGgufSteps(parseInt(e.target.value))}
                                                    className="form-range"
                                                />

                                                <label className="form-label" style={{ marginTop: '10px' }}>CFG Scale: {ggufCfgScale}</label>
                                                <input
                                                    type="range"
                                                    min="1"
                                                    max="30"
                                                    step="0.5"
                                                    value={ggufCfgScale}
                                                    onChange={(e) => setGgufCfgScale(parseFloat(e.target.value))}
                                                    className="form-range"
                                                />

                                                <label className="form-label" style={{ marginTop: '10px' }}>Sampler</label>
                                                <select
                                                    className="form-input"
                                                    value={selectedGgufSampler}
                                                    onChange={(e) => setSelectedGgufSampler(e.target.value)}
                                                >
                                                    {availableSamplers.map(s => <option key={s} value={s}>{s}</option>)}
                                                </select>

                                                <label className="form-label" style={{ marginTop: '10px' }}>Scheduler</label>
                                                <select
                                                    className="form-input"
                                                    value={selectedGgufScheduler}
                                                    onChange={(e) => setSelectedGgufScheduler(e.target.value)}
                                                >
                                                    {availableSchedulers.map(s => <option key={s} value={s}>{s}</option>)}
                                                </select>

                                                <label className="form-label" style={{ marginTop: '10px' }}>Denoise: {ggufDenoise}</label>
                                                <input
                                                    type="range"
                                                    min="0"
                                                    max="1"
                                                    step="0.01"
                                                    value={ggufDenoise}
                                                    onChange={(e) => setGgufDenoise(parseFloat(e.target.value))}
                                                    className="form-range"
                                                />
                                            </div>
                                        </div>
                                    </div>

                                    {/* Image Settings */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-dimensions') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-dimensions')}
                                        >
                                            <span>ðŸ“ Image Settings</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-dimensions') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-dimensions') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <label className="form-label">Width</label>
                                                <input
                                                    type="number"
                                                    className="form-input"
                                                    value={ggufWidth}
                                                    onChange={(e) => setGgufWidth(parseInt(e.target.value))}
                                                    min="64"
                                                    step="64"
                                                />

                                                <label className="form-label" style={{ marginTop: '10px' }}>Height</label>
                                                <input
                                                    type="number"
                                                    className="form-input"
                                                    value={ggufHeight}
                                                    onChange={(e) => setGgufHeight(parseInt(e.target.value))}
                                                    min="64"
                                                    step="64"
                                                />

                                                <label className="form-label" style={{ marginTop: '10px' }}>Batch Size</label>
                                                <input
                                                    type="number"
                                                    className="form-input"
                                                    value={ggufBatchSize}
                                                    onChange={(e) => setGgufBatchSize(parseInt(e.target.value))}
                                                    min="1"
                                                />
                                            </div>
                                        </div>
                                    </div>

                                    {/* Watermark */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-watermark') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-watermark')}
                                        >
                                            <span>ðŸ’§ Watermark</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-watermark') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-watermark') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <label className="form-label">Watermark Text</label>
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    value={ggufWatermarkText}
                                                    onChange={(e) => setGgufWatermarkText(e.target.value)}
                                                />
                                            </div>
                                        </div>
                                    </div>

                                    {/* Face Swap */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-faceswap') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-faceswap')}
                                        >
                                            <span>ðŸ‘¤ Face Swap</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-faceswap') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-faceswap') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div className="form-group">
                                                    <label className="form-label">
                                                        <input
                                                            type="checkbox"
                                                            checked={faceSwapEnabled}
                                                            onChange={(e) => setFaceSwapEnabled(e.target.checked)}
                                                            style={{ marginRight: '6px' }}
                                                        />
                                                        Enable Face Swap (Faceless)
                                                    </label>
                                                    <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '4px' }}>
                                                        Swap face using Faceless reactor node
                                                    </div>
                                                </div>
                                                {faceSwapEnabled && (
                                                    <div className="form-group" style={{ marginTop: '10px' }}>
                                                        <input
                                                            type="file"
                                                            ref={faceUploadRef}
                                                            accept="image/*"
                                                            onChange={handleFaceUpload}
                                                            style={{ display: 'none' }}
                                                        />
                                                        <button
                                                            className="btn btn-secondary btn-small"
                                                            onClick={() => faceUploadRef.current?.click()}
                                                        >
                                                            {faceSwapImage ? 'Change Face Image' : 'Upload Face Image'}
                                                        </button>
                                                        {faceSwapImagePreview && (
                                                            <img
                                                                src={faceSwapImagePreview}
                                                                className="face-upload-preview"
                                                                alt="Face swap preview"
                                                            />
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Upscale */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-upscale') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-upscale')}
                                        >
                                            <span>ðŸ” Upscale</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-upscale') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-upscale') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div className="form-group">
                                                    <label className="form-label">
                                                        <input
                                                            type="checkbox"
                                                            checked={upscaleEnabled}
                                                            onChange={(e) => setUpscaleEnabled(e.target.checked)}
                                                            style={{ marginRight: '6px' }}
                                                        />
                                                        Enable Upscaling
                                                    </label>
                                                </div>
                                                {upscaleEnabled && (
                                                    <>
                                                        <div className="form-group" style={{ marginTop: '10px' }}>
                                                            <label className="form-label">Upscale Model</label>
                                                            <select
                                                                className="form-input"
                                                                value={upscaleModel}
                                                                onChange={(e) => setUpscaleModel(e.target.value)}
                                                            >
                                                                {availableUpscalers.map(u => <option key={u} value={u}>{u}</option>)}
                                                            </select>
                                                        </div>
                                                        <div className="form-group" style={{ marginTop: '10px' }}>
                                                            <label className="form-label">Upscale Factor</label>
                                                            <select
                                                                className="form-input"
                                                                value={upscaleFactor}
                                                                onChange={(e) => setUpscaleFactor(parseFloat(e.target.value))}
                                                            >
                                                                <option value="2">2x</option>
                                                                <option value="4">4x</option>
                                                            </select>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Embeddings */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-embeddings') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-embeddings')}
                                        >
                                            <span>ðŸ“¦ Embeddings</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-embeddings') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-embeddings') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div style={{ marginBottom: '8px', fontSize: '11px', color: '#9ca3af' }}>
                                                    Available Embeddings:
                                                </div>
                                                <div style={{ maxHeight: '150px', overflowY: 'auto' }}>
                                                    {availableEmbeddings.length > 0 ? (
                                                        availableEmbeddings.map(emb => (
                                                            <div key={emb} style={{ fontSize: '11px', padding: '4px 0', color: '#e5e7eb' }}>
                                                                {emb}
                                                            </div>
                                                        ))
                                                    ) : (
                                                        <div style={{ fontSize: '11px', color: '#6b7280' }}>No embeddings found</div>
                                                    )}
                                                </div>
                                                <div style={{ fontSize: '10px', color: '#9ca3af', marginTop: '8px' }}>
                                                    Use embeddings in your prompt with the format: embedding:filename
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Image to Image */}
                                    <div className="accordion-section">
                                        <div
                                            className={`accordion-header ${openGgufAccordions.includes('gguf-img2img') ? 'active' : ''}`}
                                            onClick={() => toggleGgufAccordion('gguf-img2img')}
                                        >
                                            <span>ðŸ–¼ï¸ Image to Image</span>
                                            <span className={`accordion-icon ${openGgufAccordions.includes('gguf-img2img') ? 'rotated' : ''}`}>â–¶</span>
                                        </div>
                                        <div className={`accordion-content ${openGgufAccordions.includes('gguf-img2img') ? 'open' : ''}`}>
                                            <div className="accordion-body">
                                                <div className="form-group">
                                                    <label className="form-label">
                                                        <input
                                                            type="checkbox"
                                                            checked={img2imgEnabled}
                                                            onChange={(e) => setImg2imgEnabled(e.target.checked)}
                                                            style={{ marginRight: '6px' }}
                                                        />
                                                        Enable Image to Image
                                                    </label>
                                                </div>
                                                {img2imgEnabled && (
                                                    <>
                                                        <div className="form-group" style={{ marginTop: '10px' }}>
                                                            <input
                                                                type="file"
                                                                ref={img2imgUploadRef}
                                                                accept="image/*"
                                                                onChange={handleImg2ImgUpload}
                                                                style={{ display: 'none' }}
                                                            />
                                                            <button
                                                                className="btn btn-secondary btn-small"
                                                                onClick={() => img2imgUploadRef.current?.click()}
                                                            >
                                                                {img2imgImage ? 'Change Image' : 'Upload Image'}
                                                            </button>
                                                            {img2imgImagePreview && (
                                                                <div style={{ marginTop: '8px' }}>
                                                                    <img src={img2imgImagePreview} style={{ width: '100%', borderRadius: '4px' }} />
                                                                </div>
                                                            )}
                                                        </div>
                                                        <div className="form-group" style={{ marginTop: '10px' }}>
                                                            <label className="form-label">Denoising Strength: {img2imgStrength}</label>
                                                            <input
                                                                type="range"
                                                                className="form-range"
                                                                min="0"
                                                                max="1"
                                                                step="0.05"
                                                                value={img2imgStrength}
                                                                onChange={(e) => setImg2imgStrength(parseFloat(e.target.value))}
                                                            />
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Generate Button */}
                                    <button
                                        className="btn btn-primary btn-large"
                                        onClick={generateGgufImage}
                                        disabled={ggufGenerating || generating || !connected}
                                        style={{ width: '100%', marginTop: '8px' }}
                                    >
                                        {ggufGenerating ? 'â³ Generating...' : 'âš¡ Generate with GGUF'}
                                    </button>
                                </div>

                                {/* RIGHT COLUMN: Preview & Generate */}
                                <div className="preview-panel">
                                    <div className="preview-header">
                                        <h3 style={{ fontSize: '14px', fontWeight: 600 }}>Preview</h3>
                                    </div>

                                    <div className="preview-content">
                                        {generating || ggufGenerating ? (
                                            <div className="progress-container">
                                                <div className="progress-bar">
                                                    <div className="progress-bar-inner" style={{ width: `${progress}%` }}></div>
                                                </div>
                                                <div className="progress-text">{progressText}</div>
                                            </div>
                                        ) : latestImage ? (
                                            <img src={latestImage} alt="Latest generation" style={{ maxWidth: '100%', borderRadius: '12px' }} />
                                        ) : (
                                            <div style={{ textAlign: 'center', color: '#6b7280', fontSize: '13px', padding: '40px' }}>
                                                Generated images will appear here
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* GALLERY TAB */}
                    <div className={`tab-content ${activeTab === 'gallery' ? 'active' : ''}`}>
                        <div className="gallery-panel">
                            <div className="gallery-header">
                                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                    <h2 style={{ fontSize: '18px', fontWeight: 700, margin: 0 }}>Gallery</h2>
                                    <span className="badge">
                                        {generatedImages.length} Item{generatedImages.length !== 1 ? 's' : ''}
                                    </span>
                                    <span className={`status-indicator ${connected ? 'status-connected' : 'status-disconnected'}`}>
                                        <span style={{
                                            width: '8px',
                                            height: '8px',
                                            borderRadius: '50%',
                                            background: 'currentColor',
                                            display: 'inline-block'
                                        }} />
                                        {connected ? 'Connected' : 'Disconnected'}
                                    </span>
                                </div>
                                <div>
                                    {generatedImages.length > 0 && (
                                        <button className="btn btn-secondary btn-small" onClick={clearAll}>
                                            ðŸ—‘ï¸ Clear All
                                        </button>
                                    )}
                                </div>
                            </div>

                            <div className="gallery-content">
                                {generatedImages.length === 0 ? (
                                    <div className="gallery-empty">
                                        <div style={{ fontSize: '64px', marginBottom: '16px' }}>ðŸŽ¨</div>
                                        <h3 style={{ fontSize: '16px', fontWeight: 600, marginBottom: '8px' }}>No Images Yet</h3>
                                        <p style={{
                                            fontSize: '12px',
                                            color: '#9ca3af',
                                            textAlign: 'center',
                                            maxWidth: '400px',
                                            marginBottom: '20px'
                                        }}>
                                            Configure your settings, save presets, and click Generate!
                                        </p>
                                    </div>
                                ) : (
                                    <>
                                        <div className="gallery-grid">
                                            {displayedImages.map((item, index) => (
                                                <div
                                                    key={startGalleryIndex + index}
                                                    className="gallery-item"
                                                    onClick={() => setSelectedImage(item)}
                                                >
                                                    {item.isVideo ? (
                                                        <video
                                                            src={item.url}
                                                            controls
                                                            style={{ width: '100%', height: '100%', objectFit: 'cover' }}
                                                        />
                                                    ) : (
                                                        <img src={item.url} alt={`Generated ${index}`} />
                                                    )}
                                                    {/* Watermark overlay */}
                                                    {item.metadata && item.metadata.watermark && (
                                                        <div className="gallery-item-watermark">{item.metadata.watermark}</div>
                                                    )}
                                                    <div className="gallery-item-info">
                                                        <div className="gallery-item-tag">
                                                            {item.metadata && item.metadata.selectedModel
                                                                ? item.metadata.selectedModel
                                                                : (item.isVideo ? 'Video' : 'Unknown model')}
                                                        </div>
                                                        <div className="gallery-item-size">
                                                            {item.isVideo
                                                                ? ((item.metadata?.length || videoLength) + 's ' + (item.metadata?.fps || frameRate) + 'fps')
                                                                : ((item.metadata && item.metadata.width) + 'Ã—' + (item.metadata && item.metadata.height))}
                                                            {item.metadata && item.metadata.timestamp && (
                                                                <> Â· {new Date(item.metadata.timestamp).toLocaleString()}</>
                                                            )}
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                        {/* Pagination controls */}
                                        {generatedImages.length > imagesPerPage && (
                                            <div className="gallery-pagination">
                                                <button className="pagination-button" onClick={prevGalleryPage} disabled={galleryPage === 1}>Prev</button>
                                                <span style={{ fontSize: '11px' }}>Page {galleryPage} of {totalGalleryPages}</span>
                                                <button className="pagination-button" onClick={nextGalleryPage} disabled={galleryPage === totalGalleryPages}>Next</button>
                                            </div>
                                        )}
                                    </>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* PROMPT LIBRARY TAB */}
                    <div className={`tab-content ${activeTab === 'library' ? 'active' : ''}`}>
                        <div className="gallery-panel" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸ“š Prompt Library</div>
                                    <div className="panel-subtitle">Manage your saved prompts</div>
                                </div>
                                <button className="btn btn-secondary btn-small" onClick={addNewPrompt}>ï¼‹ Add</button>
                            </div>
                            {/* Search bar and tag filter */}
                            <div className="search-bar">
                                <input
                                    type="text"
                                    placeholder="Search prompts..."
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                />
                            </div>
                            <div style={{ marginBottom: '8px', display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                                {Array.from(new Set(promptLibrary.flatMap(p => (p.tags || [])))).map((tag) => (
                                    <span
                                        key={tag}
                                        className="tag-badge"
                                        onClick={() => setSelectedTag(selectedTag === tag ? null : tag)}
                                        style={selectedTag === tag ? { background: 'rgba(99,102,241,1)' } : {}}
                                    >
                                        {tag}
                                    </span>
                                ))}
                                {selectedTag && (
                                    <span
                                        className="tag-badge"
                                        onClick={() => setSelectedTag(null)}
                                        style={{ background: 'rgba(239,68,68,0.8)' }}
                                    >
                                        Clear filter
                                    </span>
                                )}
                            </div>
                            <div style={{ flex: 1, display: 'flex', gap: '16px', overflow: 'hidden' }}>
                                {/* Left column: list view with CRUD actions */}
                                <div className="library-list-column" style={{ width: '280px', flexShrink: 0, overflowY: 'auto', paddingRight: '4px' }}>
                                    {filteredPrompts.length === 0 && (
                                        <div style={{ fontSize: '12px', color: '#6b7280' }}>No prompts match your search.</div>
                                    )}
                                    {filteredPrompts.map((item, idx) => (
                                        <div key={idx} className="library-list-item" style={{
                                            padding: '6px 8px',
                                            borderRadius: '8px',
                                            border: '1px solid rgba(55,65,81,0.9)',
                                            marginBottom: '6px',
                                            fontSize: '11px',
                                            display: 'flex',
                                            flexDirection: 'column',
                                            gap: '4px'
                                        }}>
                                            <div style={{ fontWeight: 600, wordBreak: 'break-word' }}>{item.prompt}</div>
                                            {item.negativePrompt && item.negativePrompt.trim() !== '' && (
                                                <div style={{ fontSize: '10px', color: '#f87171' }}>Neg: {item.negativePrompt}</div>
                                            )}
                                            {(item.tags || []).length > 0 && (
                                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '2px' }}>
                                                    {(item.tags || []).map((tag, tIdx) => (
                                                        <span
                                                            key={tIdx}
                                                            className="tag-badge"
                                                            onClick={() => setSelectedTag(tag)}
                                                            style={{ fontSize: '9px' }}
                                                        >
                                                            {tag}
                                                        </span>
                                                    ))}
                                                </div>
                                            )}
                                            <div style={{ display: 'flex', gap: '4px' }}>
                                                <button className="btn btn-secondary btn-small" onClick={() => {
                                                    setPrompt(item.prompt);
                                                    setNegativePrompt(item.negativePrompt || '');
                                                }} style={{ fontSize: '10px' }}>
                                                    ðŸŽ¯ Use
                                                </button>
                                                <button className="btn btn-secondary btn-small" onClick={() => editPromptInLibrary(idx)} style={{ fontSize: '10px' }}>
                                                    âœï¸ Edit
                                                </button>
                                                <button className="btn btn-secondary btn-small" onClick={() => deletePromptFromLibrary(idx)} style={{ fontSize: '10px' }}>
                                                    ðŸ—‘ï¸ Delete
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                {/* Right column: card grid with pagination */}
                                <div className="library-cards-column" style={{ flex: 1, overflowY: 'auto', paddingRight: '4px' }}>
                                    {displayedPromptCards.length === 0 && (
                                        <div style={{ fontSize: '12px', color: '#6b7280' }}>No prompts match your search.</div>
                                    )}
                                    {displayedPromptCards.length > 0 && (
                                        <div className="prompt-card-grid">
                                            {displayedPromptCards.map((item, idx) => (
                                                <div key={startPromptIndex + idx} className="prompt-card" onClick={() => {
                                                    setPrompt(item.prompt);
                                                    setNegativePrompt(item.negativePrompt || '');
                                                }}>
                                                    <div className="prompt-card-header">{item.prompt}</div>
                                                    {item.negativePrompt && item.negativePrompt.trim() !== '' && (
                                                        <div className="prompt-card-negative">Neg: {item.negativePrompt}</div>
                                                    )}
                                                    {(item.tags || []).length > 0 && (
                                                        <div className="prompt-card-tags">
                                                            {(item.tags || []).map((tag, tIdx) => (
                                                                <span key={tIdx} className="tag-badge" onClick={(e) => { e.stopPropagation(); setSelectedTag(tag); }}>
                                                                    {tag}
                                                                </span>
                                                            ))}
                                                        </div>
                                                    )}
                                                    <div className="prompt-card-actions">
                                                        <button className="btn btn-secondary btn-small" onClick={(e) => { e.stopPropagation(); setPrompt(item.prompt); setNegativePrompt(item.negativePrompt || ''); }} style={{ fontSize: '10px' }}>
                                                            ðŸŽ¯ Use
                                                        </button>
                                                        <button className="btn btn-secondary btn-small" onClick={(e) => { e.stopPropagation(); editPromptInLibrary((promptLibrary.indexOf(item))); }} style={{ fontSize: '10px' }}>
                                                            âœï¸ Edit
                                                        </button>
                                                        <button className="btn btn-secondary btn-small" onClick={(e) => { e.stopPropagation(); deletePromptFromLibrary((promptLibrary.indexOf(item))); }} style={{ fontSize: '10px' }}>
                                                            ðŸ—‘ï¸ Delete
                                                        </button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    {filteredPrompts.length > promptsPerPage && (
                                        <div className="gallery-pagination" style={{ marginTop: '10px' }}>
                                            <button className="pagination-button" onClick={prevPromptPage} disabled={promptPage === 1}>Prev</button>
                                            <span style={{ fontSize: '11px' }}>Page {promptPage} of {totalPromptPages}</span>
                                            <button className="pagination-button" onClick={nextPromptPage} disabled={promptPage === totalPromptPages}>Next</button>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* SETTINGS TAB */}
                    {/* PRO PROMPTS TAB */}
                    <div className={`tab-content ${activeTab === 'prompts' ? 'active' : ''}`}>
                        <div className="gallery-panel">
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸ“ Pro Prompt Library</div>
                                    <div className="panel-subtitle">Professional-grade prompts for stunning results</div>
                                </div>
                            </div>

                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(320px, 1fr))', gap: '12px', padding: '12px', overflowY: 'auto', maxHeight: 'calc(100vh - 180px)' }}>

                                {/* Portrait Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Professional portrait photography, elegant woman with flowing hair, soft studio lighting, 85mm lens, shallow depth of field, bokeh background, high detail, photorealistic, natural skin texture, professional color grading');
                                    setNegativePrompt('cartoon, anime, illustration, deformed, distorted, disfigured, poorly drawn, bad anatomy, wrong anatomy, extra limb, missing limb, floating limbs, disconnected limbs, mutation, mutated, ugly, disgusting, blurry, amputation');
                                }}>
                                    <div className="prompt-card-header">ðŸŽ­ Portrait Photography</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Professional studio portrait with elegant lighting and shallow DOF</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Portrait</span>
                                        <span className="tag-badge">Photography</span>
                                        <span className="tag-badge">Professional</span>
                                    </div>
                                </div>

                                {/* Cinematic Landscape */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Epic cinematic landscape, dramatic mountains at golden hour, volumetric lighting rays piercing through clouds, ultra-wide angle, 8k resolution, HDR, professional landscape photography, award-winning composition, vibrant colors');
                                    setNegativePrompt('blurry, low quality, low resolution, oversaturated, unrealistic, cartoon, illustration');
                                }}>
                                    <div className="prompt-card-header">ðŸ”ï¸ Cinematic Landscape</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Epic landscape with dramatic lighting and professional composition</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Landscape</span>
                                        <span className="tag-badge">Cinematic</span>
                                        <span className="tag-badge">Nature</span>
                                    </div>
                                </div>

                                {/* Fashion Editorial */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('High fashion editorial photography, model in designer couture dress, minimalist white background, Vogue style, professional lighting, medium format camera, sharp focus, elegant pose, luxury aesthetic, modern composition');
                                    setNegativePrompt('amateur, casual, low quality, cluttered background, distorted proportions, poor lighting');
                                }}>
                                    <div className="prompt-card-header">ðŸ‘— Fashion Editorial</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Vogue-style fashion photography with luxury aesthetic</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Fashion</span>
                                        <span className="tag-badge">Editorial</span>
                                        <span className="tag-badge">Luxury</span>
                                    </div>
                                </div>

                                {/* Product Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Premium product photography, luxury watch on marble surface, dramatic side lighting, reflections, macro detail, commercial photography, high-end advertising aesthetic, professional studio setup, 4k resolution');
                                    setNegativePrompt('cheap looking, poorly lit, amateur, cluttered, low resolution, distorted');
                                }}>
                                    <div className="prompt-card-header">âŒš Product Photography</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Commercial product shot with premium aesthetic</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Product</span>
                                        <span className="tag-badge">Commercial</span>
                                        <span className="tag-badge">Luxury</span>
                                    </div>
                                </div>

                                {/* Cyberpunk Character */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Cyberpunk character portrait, neon-lit face with glowing tech implants, futuristic cityscape background, dramatic contrast lighting, cinematic composition, ultra-detailed, photorealistic rendering, sci-fi aesthetic, moody atmosphere');
                                    setNegativePrompt('cartoonish, low detail, flat lighting, amateur, blurry, low resolution');
                                }}>
                                    <div className="prompt-card-header">ðŸ¤– Cyberpunk Character</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Futuristic character with neon aesthetics and tech implants</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Cyberpunk</span>
                                        <span className="tag-badge">SciFi</span>
                                        <span className="tag-badge">Character</span>
                                    </div>
                                </div>

                                {/* Architectural Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Modern architecture photography, minimalist building with clean lines, blue hour lighting, symmetrical composition, professional architectural photography, tilt-shift lens effect, high detail, urban landscape, contemporary design');
                                    setNegativePrompt('distorted perspective, poor composition, cluttered, low quality, amateur');
                                }}>
                                    <div className="prompt-card-header">ðŸ¢ Architecture</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Professional architectural photography with perfect symmetry</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Architecture</span>
                                        <span className="tag-badge">Modern</span>
                                        <span className="tag-badge">Urban</span>
                                    </div>
                                </div>

                                {/* Fantasy Art */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Epic fantasy art, mystical sorceress with glowing magical aura, floating crystals, ethereal light effects, detailed costume design, digital painting style, high fantasy aesthetic, dramatic composition, vibrant colors, detailed rendering');
                                    setNegativePrompt('low quality, simple, amateur, blurry, low detail, bad anatomy');
                                }}>
                                    <div className="prompt-card-header">ðŸ§™ Fantasy Art</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Epic fantasy character with magical effects and detailed rendering</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Fantasy</span>
                                        <span className="tag-badge">Magic</span>
                                        <span className="tag-badge">Digital Art</span>
                                    </div>
                                </div>

                                {/* Street Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Candid street photography, urban life moment, authentic emotion, natural lighting, photojournalistic style, Leica aesthetic, decisive moment, documentary photography, environmental portrait, storytelling composition');
                                    setNegativePrompt('posed, staged, artificial, low quality, blurry, overprocessed');
                                }}>
                                    <div className="prompt-card-header">ðŸ“¸ Street Photography</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Authentic street moment with photojournalistic aesthetic</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Street</span>
                                        <span className="tag-badge">Documentary</span>
                                        <span className="tag-badge">Urban</span>
                                    </div>
                                </div>

                                {/* Food Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Professional food photography, gourmet dish presentation, restaurant quality plating, dramatic overhead lighting, shallow depth of field, food styling, commercial photography, rich colors, appetizing composition, high detail');
                                    setNegativePrompt('unappetizing, messy, poor lighting, amateur, low quality, unappealing');
                                }}>
                                    <div className="prompt-card-header">ðŸ½ï¸ Food Photography</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Restaurant-quality food styling with professional lighting</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Food</span>
                                        <span className="tag-badge">Commercial</span>
                                        <span className="tag-badge">Gourmet</span>
                                    </div>
                                </div>

                                {/* Concept Art */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Concept art for AAA video game, detailed environment design, atmospheric perspective, professional matte painting, cinematic lighting, dramatic composition, high detail, digital illustration, game industry quality');
                                    setNegativePrompt('low detail, amateur, simple, low quality, unclear, poor composition');
                                }}>
                                    <div className="prompt-card-header">ðŸŽ® Concept Art</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Game industry-quality environment concept with professional rendering</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Concept</span>
                                        <span className="tag-badge">Game Art</span>
                                        <span className="tag-badge">Environment</span>
                                    </div>
                                </div>

                                {/* Wildlife Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Wildlife photography, majestic lion in golden savanna, National Geographic style, telephoto lens compression, perfect golden hour lighting, shallow depth of field, environmental context, professional nature photography, award-winning composition');
                                    setNegativePrompt('zoo setting, captivity, poor lighting, blurry, low quality, unnatural pose');
                                }}>
                                    <div className="prompt-card-header">ðŸ¦ Wildlife Photography</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>National Geographic-style wildlife with perfect natural lighting</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Wildlife</span>
                                        <span className="tag-badge">Nature</span>
                                        <span className="tag-badge">NatGeo</span>
                                    </div>
                                </div>

                                {/* Sci-Fi Environment */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Futuristic sci-fi cityscape, towering megastructures, flying vehicles, neon holographic advertisements, cyberpunk atmosphere, dramatic perspective, detailed architecture, concept art quality, cinematic lighting, high-tech aesthetic');
                                    setNegativePrompt('low detail, simple, amateur, poor perspective, flat lighting, low quality');
                                }}>
                                    <div className="prompt-card-header">ðŸš€ Sci-Fi Environment</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Futuristic cityscape with detailed architecture and atmosphere</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">SciFi</span>
                                        <span className="tag-badge">Environment</span>
                                        <span className="tag-badge">Futuristic</span>
                                    </div>
                                </div>

                                {/* Abstract Art */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Abstract digital art, fluid organic shapes, vibrant color palette, dynamic composition, modern art gallery quality, high resolution, professional digital painting, contemporary aesthetic, artistic expression');
                                    setNegativePrompt('chaotic, messy, low quality, unclear, amateurish, poor color harmony');
                                }}>
                                    <div className="prompt-card-header">ðŸŽ¨ Abstract Art</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Modern abstract composition with vibrant colors and dynamic flow</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Abstract</span>
                                        <span className="tag-badge">Modern</span>
                                        <span className="tag-badge">Digital Art</span>
                                    </div>
                                </div>

                                {/* Macro Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Extreme macro photography, water droplets on flower petals, crystal clear detail, perfect focus, natural morning light, professional macro lens, shallow depth of field, nature photography, high resolution, intricate texture');
                                    setNegativePrompt('blurry, out of focus, low detail, poor lighting, low quality');
                                }}>
                                    <div className="prompt-card-header">ðŸ”¬ Macro Photography</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Ultra-detailed macro with perfect focus and natural lighting</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Macro</span>
                                        <span className="tag-badge">Nature</span>
                                        <span className="tag-badge">Detail</span>
                                    </div>
                                </div>

                                {/* Automotive Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Luxury automotive photography, high-end sports car, dramatic studio lighting, reflective floor, commercial advertising aesthetic, perfect reflections, professional car photography, dynamic angle, showroom quality');
                                    setNegativePrompt('amateur, poor lighting, bad angle, low quality, distorted, cluttered background');
                                }}>
                                    <div className="prompt-card-header">ðŸš— Automotive Photography</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Commercial car photography with studio lighting and reflections</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Automotive</span>
                                        <span className="tag-badge">Commercial</span>
                                        <span className="tag-badge">Luxury</span>
                                    </div>
                                </div>

                                {/* Underwater Photography */}
                                <div className="prompt-card" onClick={() => {
                                    setPrompt('Underwater photography, vibrant coral reef ecosystem, tropical fish, crystal clear water, natural sunlight rays, professional underwater camera, National Geographic quality, marine life, detailed coral, rich colors');
                                    setNegativePrompt('murky, unclear, low visibility, poor color, low quality, amateur');
                                }}>
                                    <div className="prompt-card-header">ðŸ  Underwater Photography</div>
                                    <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>Vibrant underwater scene with coral and marine life</p>
                                    <div className="prompt-card-tags">
                                        <span className="tag-badge">Underwater</span>
                                        <span className="tag-badge">Marine</span>
                                        <span className="tag-badge">Nature</span>
                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>

                    <div className={`tab-content ${activeTab === 'settings' ? 'active' : ''}`}>
                        <div className="generation-panel" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">âš™ï¸ Settings</div>
                                    <div className="panel-subtitle">Manage your data and preferences</div>
                                </div>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', paddingRight: '4px' }}>
                                <div className="settings-section">
                                    <h4>Privacy &amp; Data</h4>
                                    <div className="settings-item">
                                        <button className="btn btn-secondary btn-small" onClick={() => {
                                            if (window.confirm('Clear prompt library? This cannot be undone.')) setPromptLibrary([]);
                                        }}>Clear Prompt Library</button>
                                    </div>
                                    <div className="settings-item">
                                        <button className="btn btn-secondary btn-small" onClick={() => {
                                            if (window.confirm('Clear gallery images? This cannot be undone.')) {
                                                setGeneratedImages([]);
                                                localStorage.removeItem('ai_studio_images');
                                            }
                                        }}>Clear Gallery</button>
                                    </div>
                                    <div className="settings-item">
                                        <button className="btn btn-secondary btn-small" onClick={() => {
                                            if (window.confirm('Clear presets? This cannot be undone.')) setPresets([]);
                                        }}>Clear Presets</button>
                                    </div>
                                    <div className="settings-item">
                                        <button className="btn btn-secondary btn-small" onClick={() => {
                                            const data = JSON.stringify(promptLibrary, null, 2);
                                            const blob = new Blob([data], { type: 'application/json' });
                                            const url = URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = 'prompt_library.json';
                                            a.click();
                                            URL.revokeObjectURL(url);
                                        }}>Export Prompt Library</button>
                                    </div>
                                    <div className="settings-item">
                                        <button className="btn btn-secondary btn-small" onClick={exportPresets}>
                                            Export Presets
                                        </button>
                                    </div>
                                    <div className="settings-item">
                                        <button className="btn btn-secondary btn-small" onClick={exportQueue}>
                                            Export Generation Queue
                                        </button>
                                    </div>
                                </div>

                                {/* Persona Selection */}
                                <div className="settings-section" style={{ marginTop: '16px' }}>
                                    <h4>Persona</h4>
                                    <div className="settings-item" style={{ display: 'flex', flexDirection: 'column', gap: '6px', fontSize: '11px', color: '#9ca3af' }}>
                                        <label>
                                            <input
                                                type="radio"
                                                name="persona"
                                                value="default"
                                                checked={selectedPersona === 'default'}
                                                onChange={(e) => setSelectedPersona(e.target.value)}
                                                style={{ marginRight: '4px' }}
                                            />
                                            Default
                                        </label>
                                        <label>
                                            <input
                                                type="radio"
                                                name="persona"
                                                value="awb"
                                                checked={selectedPersona === 'awb'}
                                                onChange={(e) => setSelectedPersona(e.target.value)}
                                                style={{ marginRight: '4px' }}
                                            />
                                            Andrew & Wendy
                                        </label>
                                        {/* When AWB persona is selected, allow enabling watermark overlay */}
                                        {selectedPersona === 'awb' && (
                                            <label style={{ marginTop: '6px', display: 'flex', alignItems: 'center' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={watermarkEnabled}
                                                    onChange={(e) => setWatermarkEnabled(e.target.checked)}
                                                    style={{ marginRight: '4px' }}
                                                />
                                                Add watermark overlay
                                            </label>
                                        )}
                                    </div>
                                </div>

                                {/* Style Pack Selection */}
                                <div className="settings-section" style={{ marginTop: '16px' }}>
                                    <h4>Theme &amp; Style</h4>
                                    <div className="settings-item" style={{ display: 'flex', flexDirection: 'column', gap: '6px', fontSize: '11px', color: '#9ca3af' }}>
                                        <label>
                                            <input
                                                type="radio"
                                                name="stylePack"
                                                value="classic"
                                                checked={stylePack === 'classic'}
                                                onChange={(e) => setStylePack(e.target.value)}
                                                style={{ marginRight: '4px' }}
                                            />
                                            Classic
                                        </label>
                                        <label>
                                            <input
                                                type="radio"
                                                name="stylePack"
                                                value="cyberpunk"
                                                checked={stylePack === 'cyberpunk'}
                                                onChange={(e) => setStylePack(e.target.value)}
                                                style={{ marginRight: '4px' }}
                                            />
                                            Cyberpunk
                                        </label>
                                        <label>
                                            <input
                                                type="radio"
                                                name="stylePack"
                                                value="watercolor"
                                                checked={stylePack === 'watercolor'}
                                                onChange={(e) => setStylePack(e.target.value)}
                                                style={{ marginRight: '4px' }}
                                            />
                                            Watercolor
                                        </label>
                                        <label>
                                            <input
                                                type="radio"
                                                name="stylePack"
                                                value="goldblack"
                                                checked={stylePack === 'goldblack'}
                                                onChange={(e) => setStylePack(e.target.value)}
                                                style={{ marginRight: '4px' }}
                                            />
                                            Gold/Black
                                        </label>
                                    </div>
                                </div>

                                {/* Smart Scheduling */}
                                <div className="settings-section" style={{ marginTop: '16px' }}>
                                    <h4>Resource Scheduling</h4>
                                    <div className="settings-item" style={{ fontSize: '11px', color: '#9ca3af' }}>
                                        <div style={{ marginBottom: '6px' }}>Max concurrent generations: {maxConcurrency}</div>
                                        <input
                                            type="range"
                                            min="1"
                                            max="3"
                                            value={maxConcurrency}
                                            onChange={(e) => setMaxConcurrency(parseInt(e.target.value))}
                                        />
                                    </div>
                                </div>

                                {/* Server Configuration */}
                                <div className="settings-section" style={{ marginTop: '16px' }}>
                                    <h4>Server Configuration</h4>
                                    <div className="settings-item" style={{ display: 'flex', flexDirection: 'column', gap: '6px' }}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                                            <label style={{ fontSize: '11px', color: '#9ca3af', width: '60px' }}>Host</label>
                                            <input
                                                type="text"
                                                className="form-input"
                                                value={serverHost}
                                                onChange={(e) => setServerHost(e.target.value)}
                                                placeholder="e.g. 192.168.0.101"
                                                style={{ flex: 1 }}
                                            />
                                        </div>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                                            <label style={{ fontSize: '11px', color: '#9ca3af', width: '60px' }}>Port</label>
                                            <input
                                                type="number"
                                                className="form-input"
                                                value={serverPort}
                                                onChange={(e) => setServerPort(e.target.value)}
                                                placeholder="e.g. 3001"
                                                style={{ flex: 1 }}
                                            />
                                        </div>
                                        <button className="btn btn-secondary btn-small" onClick={applyServerConfig}>
                                            Apply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* MODELS TAB */}
                    <div className={`tab-content ${activeTab === 'models' ? 'active' : ''}`}>
                        <div className="generation-panel" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸ“¦ Models</div>
                                    <div className="panel-subtitle">Available Comfy Models</div>
                                </div>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', paddingRight: '4px' }}>
                                {Object.keys(modelsByType).length === 0 && (
                                    <div style={{ fontSize: '12px', color: '#6b7280' }}>No models found or file system access unavailable.</div>
                                )}
                                {Object.keys(modelsByType).length > 0 && (
                                    <div className="models-grid">
                                        {Object.entries(modelsByType).map(([type, models]) => (
                                            <div key={type} className="models-column">
                                                <h4>{type}</h4>
                                                {models.length === 0 ? (
                                                    <div style={{ fontSize: '11px', color: '#6b7280' }}>No models.</div>
                                                ) : (
                                                    models.map((m, i) => (
                                                        <div key={i} className="model-item">
                                                            <span>{m}</span>
                                                            <span style={{ color: '#9ca3af', fontStyle: 'italic' }}>{getModelInfo(m)}</span>
                                                        </div>
                                                    ))
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* MANAGER TAB */}
                    <div className={`tab-content ${activeTab === 'manager' ? 'active' : ''}`}>
                        <div className="generation-panel" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸ§© Manager</div>
                                    <div className="panel-subtitle">Manage LoRAs, embeddings & train new LoRAs</div>
                                </div>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', padding: '8px' }}>
                                {/* LoRA list */}
                                <h4 style={{ fontSize: '13px', color: '#d1d5db', marginBottom: '4px' }}>Installed LoRAs ({availableLoras.length})</h4>
                                {availableLoras.length === 0 ? (
                                    <div style={{ fontSize: '11px', color: '#6b7280' }}>No LoRAs installed.</div>
                                ) : (
                                    availableLoras.map((l, idx) => (
                                        <div key={idx} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '4px 0', borderBottom: '1px solid rgba(55, 65, 81, 0.2)' }}>
                                            <span style={{ fontSize: '12px' }}>{l}</span>
                                            <button className="btn btn-secondary btn-small" onClick={() => toggleLora(l)}>
                                                {selectedLoras.some(sel => sel.name === l) ? 'Disable' : 'Enable'}
                                            </button>
                                        </div>
                                    ))
                                )}

                                {/* Embeddings list */}
                                <h4 style={{ fontSize: '13px', color: '#d1d5db', marginTop: '12px', marginBottom: '4px' }}>Installed Embeddings ({availableEmbeddings.length})</h4>
                                {availableEmbeddings.length === 0 ? (
                                    <div style={{ fontSize: '11px', color: '#6b7280' }}>No embeddings installed.</div>
                                ) : (
                                    availableEmbeddings.map((emb, idx) => (
                                        <div key={idx} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '4px 0', borderBottom: '1px solid rgba(55, 65, 81, 0.2)' }}>
                                            <span style={{ fontSize: '12px' }}>{emb}</span>
                                            <button className="btn btn-secondary btn-small" onClick={() => setPrompt(prev => prev + ` embedding:${emb}`)}>
                                                Add to Prompt
                                            </button>
                                        </div>
                                    ))
                                )}

                                {/* LoRA training */}
                                <h4 style={{ fontSize: '13px', color: '#d1d5db', marginTop: '16px', marginBottom: '4px' }}>Train New LoRA</h4>
                                <div className="form-group">
                                    <label className="form-label">Dataset (images/zip)</label>
                                    <input type="file" accept="image/*,.zip" onChange={handleLoraDatasetUpload} />
                                </div>
                                <div className="form-group">
                                    <label className="form-label">Base Model</label>
                                    <select className="form-select" value={loraTrainingModel} onChange={(e) => setLoraTrainingModel(e.target.value)}>
                                        <option value="">Select Model</option>
                                        {availableModels.map((m, i) => (
                                            <option key={i} value={m}>{m}</option>
                                        ))}
                                    </select>
                                </div>
                                <div className="form-group">
                                    <label className="form-label">Steps</label>
                                    <input type="number" className="form-input" value={loraTrainingSteps} onChange={(e) => setLoraTrainingSteps(parseInt(e.target.value) || 0)} />
                                </div>
                                <div className="form-group">
                                    <label className="form-label">Learning Rate</label>
                                    <input type="number" step="0.00001" className="form-input" value={loraTrainingLr} onChange={(e) => setLoraTrainingLr(parseFloat(e.target.value) || 0)} />
                                </div>
                                <button className="btn btn-primary btn-small" onClick={trainLora}>Train LoRA</button>
                                {loraTrainingStatus && (
                                    <div style={{ fontSize: '11px', color: '#9ca3af', marginTop: '6px' }}>{loraTrainingStatus}</div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* PROJECTS TAB */}
                    <div className={`tab-content ${activeTab === 'projects' ? 'active' : ''}`}>
                        <div className="generation-panel" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸ—‚ï¸ Projects</div>
                                    <div className="panel-subtitle">Organise your workspaces</div>
                                </div>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', padding: '8px' }}>
                                <div style={{ display: 'flex', gap: '8px', marginBottom: '8px' }}>
                                    <input className="form-input" placeholder="New project name" value={newProjectName} onChange={(e) => setNewProjectName(e.target.value)} style={{ flex: 1 }} />
                                    <button className="btn btn-secondary btn-small" onClick={addProject}>Add</button>
                                </div>
                                {projects.length === 0 ? (
                                    <div style={{ fontSize: '12px', color: '#6b7280' }}>No projects created yet.</div>
                                ) : (
                                    <ul style={{ listStyle: 'none', padding: 0 }}>
                                        {projects.map((p, i) => (
                                            <li key={i} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '6px 0', borderBottom: '1px solid rgba(55, 65, 81, 0.2)' }}>
                                                <button className="btn btn-secondary btn-small" onClick={() => selectProject(p)} style={{ flex: 1, textAlign: 'left' }}>
                                                    {currentProject === p ? 'âœ”ï¸ ' : ''}{p}
                                                </button>
                                                <button className="btn btn-secondary btn-small" onClick={() => deleteProject(p)}>ðŸ—‘ï¸</button>
                                            </li>
                                        ))}
                                    </ul>
                                )}
                                {currentProject && (
                                    <div style={{ marginTop: '12px' }}>
                                        <h4 style={{ fontSize: '13px', color: '#d1d5db' }}>Current Project: {currentProject}</h4>
                                        <div style={{ fontSize: '11px', color: '#9ca3af', marginTop: '4px' }}>All outputs and presets will be saved under this project.</div>
                                    </div>
                                )}

                                {/* Show AWB campaign quick actions when the AWB persona is selected */}
                                {selectedPersona === 'awb' && (
                                    <div style={{ marginTop: '16px' }}>
                                        <h4 style={{ fontSize: '13px', color: '#d1d5db', marginBottom: '4px' }}>AWB Campaigns</h4>
                                        <ul style={{ listStyle: 'none', padding: 0 }}>
                                            {awbCampaigns.map((camp, i) => (
                                                <li key={i} style={{ marginBottom: '8px', borderBottom: '1px solid rgba(55, 65, 81, 0.2)', padding: '6px 0' }}>
                                                    <div style={{ fontSize: '12px', fontWeight: 600, color: '#cbd5e1' }}>{camp.name}</div>
                                                    <div style={{ fontSize: '10px', color: '#9ca3af', marginBottom: '4px' }}>{camp.description}</div>
                                                    <button className="btn btn-secondary btn-small" onClick={() => useCampaign(camp)}>Use</button>
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* CAPTION TAB */}
                    <div className={`tab-content ${activeTab === 'caption' ? 'active' : ''}`}>
                        <div className="generation-panel" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸ·ï¸ Caption Generator</div>
                                    <div className="panel-subtitle">Generate tags and descriptions for your images</div>
                                </div>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', padding: '8px' }}>
                                <div className="form-group">
                                    <label className="form-label">Upload Image</label>
                                    <input type="file" accept="image/*" onChange={handleCaptionUpload} />
                                    {captionImagePreview && (
                                        <img src={captionImagePreview} alt="Preview" style={{ width: '100%', borderRadius: '6px', marginTop: '8px' }} />
                                    )}
                                </div>
                                <button className="btn btn-primary btn-small" onClick={generateCaption} disabled={!captionImage}>
                                    Generate Tags & Caption
                                </button>
                                {captionTags.length > 0 && (
                                    <div style={{ marginTop: '12px' }}>
                                        <h4 style={{ fontSize: '13px', color: '#d1d5db', marginBottom: '4px' }}>Tags</h4>
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                                            {captionTags.map((tag, i) => (
                                                <span key={i} style={{ fontSize: '11px', background: 'rgba(129, 140, 248, 0.25)', padding: '2px 6px', borderRadius: '4px' }}>{tag}</span>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                {captionDescription && (
                                    <div style={{ marginTop: '12px' }}>
                                        <h4 style={{ fontSize: '13px', color: '#d1d5db', marginBottom: '4px' }}>Description</h4>
                                        <p style={{ fontSize: '11px', color: '#d1d5db' }}>{captionDescription}</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* MARKETING TAB */}
                    <div className={`tab-content ${activeTab === 'marketing' ? 'active' : ''}`}>
                        <div className="generation-panel" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸ“£ Marketing & Scheduling</div>
                                    <div className="panel-subtitle">Plan revenue streams and schedule posts</div>
                                </div>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', padding: '8px' }}>
                                <h4 style={{ fontSize: '13px', color: '#d1d5db', marginBottom: '6px' }}>Revenue Streams</h4>
                                <ul style={{ fontSize: '11px', color: '#9ca3af', marginBottom: '12px', paddingLeft: '16px', listStyleType: 'disc' }}>
                                    <li>Merchandise line (apparel, prints, NFTs)</li>
                                    <li>Sponsored brand campaigns</li>
                                    <li>Social media subscriptions & digital products</li>
                                    <li>Workshops and masterclasses</li>
                                </ul>
                                <h4 style={{ fontSize: '13px', color: '#d1d5db', marginBottom: '6px' }}>Schedule a Post</h4>
                                <div className="form-group">
                                    <label className="form-label">Platform</label>
                                    <select className="form-select" value={newPostPlatform} onChange={(e) => setNewPostPlatform(e.target.value)}>
                                        <option>Instagram</option>
                                        <option>Facebook</option>
                                        <option>X</option>
                                    </select>
                                </div>
                                <div className="horizontal-row">
                                    <div className="form-group">
                                        <label className="form-label">Date</label>
                                        <input type="date" className="form-input" value={newPostDate} onChange={(e) => setNewPostDate(e.target.value)} />
                                    </div>
                                    <div className="form-group">
                                        <label className="form-label">Time</label>
                                        <input type="time" className="form-input" value={newPostTime} onChange={(e) => setNewPostTime(e.target.value)} />
                                    </div>
                                </div>
                                <div className="form-group">
                                    <label className="form-label">Content</label>
                                    <textarea className="form-textarea" value={newPostContent} onChange={(e) => setNewPostContent(e.target.value)} placeholder="Write your caption or description here..." />
                                </div>
                                <button className="btn btn-primary btn-small" onClick={handleSchedulePost} disabled={!newPostDate || !newPostTime || !newPostContent.trim()}>Schedule Post</button>
                                {scheduledPosts.length > 0 && (
                                    <div style={{ marginTop: '16px' }}>
                                        <h4 style={{ fontSize: '13px', color: '#d1d5db', marginBottom: '4px' }}>Scheduled Posts</h4>
                                        {scheduledPosts.map((post) => (
                                            <div key={post.id} style={{ border: '1px solid rgba(55,65,81,0.8)', borderRadius: '8px', padding: '8px', marginBottom: '8px', fontSize: '11px' }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                    <div>
                                                        <strong style={{ color: '#a5b4fc' }}>{post.platform}</strong>
                                                        <span style={{ color: '#9ca3af', marginLeft: '6px' }}>{post.datetime}</span>
                                                    </div>
                                                    <div>
                                                        <button className="btn btn-secondary btn-small" onClick={() => markScheduledPost(post.id)} style={{ marginRight: '4px' }}>
                                                            {post.status === 'pending' ? 'Mark Posted' : 'Mark Pending'}
                                                        </button>
                                                        <button className="btn btn-secondary btn-small" onClick={() => deleteScheduledPost(post.id)}>Delete</button>
                                                    </div>
                                                </div>
                                                <div style={{ marginTop: '4px', color: '#d1d5db' }}>{post.content}</div>
                                                <div style={{ marginTop: '2px', fontSize: '9px', color: post.status === 'pending' ? '#fde68a' : '#6ee7b7' }}>
                                                    Status: {post.status}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* SOCIAL TAB */}
                    <div className={`tab-content ${activeTab === 'social' ? 'active' : ''}`}>
                        <div className="generation-panel" style={{ display: 'flex', flexDirection: 'column' }}>
                            <div className="panel-header">
                                <div>
                                    <div className="panel-title">ðŸ“± Social Accounts</div>
                                    <div className="panel-subtitle">Connect your social profiles</div>
                                </div>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', padding: '8px' }}>
                                {/* Instagram */}
                                <div className="settings-section">
                                    <h4>Instagram</h4>
                                    <div className="settings-item" style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                        <label style={{ fontSize: '11px', color: '#9ca3af' }}>Username</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={instagramUsername}
                                            onChange={(e) => setInstagramUsername(e.target.value)}
                                            placeholder="your_instagram"
                                        />
                                        <button className="btn btn-secondary btn-small" onClick={() => checkSocial('Instagram')} style={{ marginTop: '4px' }}>Check Account</button>
                                        <div style={{ fontSize: '9px', color: '#6b7280', marginTop: '2px' }}>
                                            Future API integration will allow fetching posts and analytics.
                                        </div>
                                    </div>
                                </div>
                                {/* Facebook */}
                                <div className="settings-section" style={{ marginTop: '16px' }}>
                                    <h4>Facebook</h4>
                                    <div className="settings-item" style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                        <label style={{ fontSize: '11px', color: '#9ca3af' }}>Username</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={facebookUsername}
                                            onChange={(e) => setFacebookUsername(e.target.value)}
                                            placeholder="your_facebook"
                                        />
                                        <button className="btn btn-secondary btn-small" onClick={() => checkSocial('Facebook')} style={{ marginTop: '4px' }}>Check Account</button>
                                        <div style={{ fontSize: '9px', color: '#6b7280', marginTop: '2px' }}>
                                            Future API integration will allow fetching posts and analytics.
                                        </div>
                                    </div>
                                </div>
                                {/* X (formerly Twitter) */}
                                <div className="settings-section" style={{ marginTop: '16px' }}>
                                    <h4>X (Twitter)</h4>
                                    <div className="settings-item" style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                        <label style={{ fontSize: '11px', color: '#9ca3af' }}>Username</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={xUsername}
                                            onChange={(e) => setXUsername(e.target.value)}
                                            placeholder="your_username"
                                        />
                                        <button className="btn btn-secondary btn-small" onClick={() => checkSocial('X')} style={{ marginTop: '4px' }}>Check Account</button>
                                        <div style={{ fontSize: '9px', color: '#6b7280', marginTop: '2px' }}>
                                            Future API integration will allow fetching posts and analytics.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {selectedImage && (
                        <div className="image-modal" onClick={() => setSelectedImage(null)}>
                            <button className="modal-close" onClick={() => setSelectedImage(null)}>âœ•</button>
                            <div className="image-modal-content" onClick={(e) => e.stopPropagation()}>
                                <div className="modal-left">
                                    {selectedImage.isVideo ? (
                                        <video
                                            src={selectedImage.url}
                                            controls
                                            className="modal-image"
                                            style={{ width: '100%' }}
                                        />
                                    ) : (
                                        <img
                                            src={selectedImage.url}
                                            alt="Full size"
                                            className="modal-image"
                                        />
                                    )}
                                </div>

                                <div className="modal-right">
                                    <h3
                                        style={{
                                            fontSize: '16px',
                                            fontWeight: 700,
                                            marginBottom: '10px',
                                            color: '#667eea',
                                        }}
                                    >
                                        {selectedImage.isVideo ? 'Video Metadata' : 'Image Metadata'}
                                    </h3>

                                    {selectedImage.metadata && (
                                        <>
                                            {/* Prompt */}
                                            <div className="metadata-section">
                                                <div className="metadata-title">Prompt</div>
                                                <div className="metadata-prompt">
                                                    {selectedImage.metadata.prompt || 'No prompt'}
                                                </div>
                                                <div className="metadata-buttons">
                                                    <button
                                                        className="btn btn-secondary btn-small"
                                                        onClick={() =>
                                                            copyPromptToClipboard(selectedImage.metadata.prompt || '')
                                                        }
                                                    >
                                                        ðŸ“‹ Copy Prompt
                                                    </button>
                                                </div>
                                            </div>

                                            {/* Negative Prompt */}
                                            {selectedImage.metadata.negativePrompt &&
                                                selectedImage.metadata.negativePrompt.trim() !== '' && (
                                                    <div className="metadata-section">
                                                        <div className="metadata-title">Negative Prompt</div>
                                                        <div className="metadata-prompt">
                                                            {selectedImage.metadata.negativePrompt}
                                                        </div>
                                                        <div className="metadata-buttons">
                                                            <button
                                                                className="btn btn-secondary btn-small"
                                                                onClick={() =>
                                                                    copyPromptToClipboard(
                                                                        selectedImage.metadata.negativePrompt || ''
                                                                    )
                                                                }
                                                            >
                                                                ðŸ“‹ Copy Negative
                                                            </button>
                                                        </div>
                                                    </div>
                                                )}

                                            {/* Video vs Image settings */}
                                            {selectedImage.isVideo ? (
                                                <div className="metadata-section">
                                                    <div className="metadata-title">Video Settings</div>
                                                    <div className="metadata-item">
                                                        <div className="metadata-label">Length</div>
                                                        <div className="metadata-value">
                                                            {selectedImage.metadata.length || videoLength}s
                                                        </div>
                                                    </div>
                                                    <div className="metadata-item">
                                                        <div className="metadata-label">Frame Rate</div>
                                                        <div className="metadata-value">
                                                            {selectedImage.metadata.fps || frameRate} fps
                                                        </div>
                                                    </div>
                                                </div>
                                            ) : (
                                                <div className="metadata-section">
                                                    <div className="metadata-title">Generation Settings</div>

                                                    <div className="metadata-item">
                                                        <div className="metadata-label">Model</div>
                                                        <div className="metadata-value">
                                                            {selectedImage.metadata.selectedModel || 'Unknown'}
                                                        </div>
                                                    </div>

                                                    <div className="metadata-item">
                                                        <div className="metadata-label">Size</div>
                                                        <div className="metadata-value">
                                                            {selectedImage.metadata.width} Ã—{` `}
                                                            {selectedImage.metadata.height}
                                                        </div>
                                                    </div>

                                                    <div className="metadata-item">
                                                        <div className="metadata-label">Steps / CFG</div>
                                                        <div className="metadata-value">
                                                            {selectedImage.metadata.steps} steps Â· CFG {selectedImage.metadata.cfg}
                                                        </div>
                                                    </div>

                                                    {/* LoRAs */}
                                                    {selectedImage.metadata.selectedLoras &&
                                                        selectedImage.metadata.selectedLoras.length > 0 && (
                                                            <div
                                                                className="metadata-item"
                                                                style={{
                                                                    display: 'flex',
                                                                    flexDirection: 'column',
                                                                    alignItems: 'flex-start',
                                                                    marginTop: '6px',
                                                                }}
                                                            >
                                                                <div className="metadata-label">LoRAs</div>
                                                                <div className="metadata-lora-list">
                                                                    {selectedImage.metadata.selectedLoras.map(
                                                                        (lora, i) => (
                                                                            <div
                                                                                key={i}
                                                                                className="metadata-value"
                                                                                style={{
                                                                                    fontSize: '11px',
                                                                                    marginBottom: '4px',
                                                                                }}
                                                                            >
                                                                                {lora.name} ({lora.strength})
                                                                            </div>
                                                                        )
                                                                    )}
                                                                </div>
                                                            </div>
                                                        )}

                                                    {/* Face Swap */}
                                                    {selectedImage.metadata.faceSwapEnabled && (
                                                        <div className="metadata-item">
                                                            <div className="metadata-label">Face Swap</div>
                                                            <div className="metadata-value">Enabled (Faceless)</div>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
        <span></span></script>
</body>

</html>